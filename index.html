<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#F2F2F7">
    <title>Audiobook Manager</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- EPUB.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { sans: ['-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'sans-serif'] },
                    colors: {
                        ios: { bg: '#F2F2F7', card: '#FFFFFF', blue: '#007AFF', red: '#FF3B30', gray: '#8E8E93', border: '#C6C6C8' }
                    },
                    boxShadow: { 'ios': '0 2px 12px rgba(0,0,0,0.06)', 'ios-float': '0 8px 30px rgba(0,0,0,0.12)' },
                    keyframes: {
                        slideUp: { '0%': { transform: 'translateY(100%)', opacity: 0 }, '100%': { transform: 'translateY(0)', opacity: 1 } },
                        fadeIn: { '0%': { opacity: 0 }, '100%': { opacity: 1 } },
                        slideInRight: { '0%': { transform: 'translateX(100%)' }, '100%': { transform: 'translateX(0)' } }
                    },
                    animation: { 
                        slideUp: 'slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards',
                        fadeIn: 'fadeIn 0.2s ease-out forwards',
                        slideInRight: 'slideInRight 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards'
                    }
                }
            }
        }
    </script>
    <style>
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .safe-top { padding-top: max(env(safe-area-inset-top), 20px); }
        .safe-bottom { padding-bottom: max(env(safe-area-inset-bottom), 20px); }
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 24px; width: 24px; border-radius: 50%;
            background: #fff; box-shadow: 0 2px 6px rgba(0,0,0,0.3); margin-top: -10px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: rgba(0,0,0,0.1); border-radius: 2px;
        }
        .dialogue-text { display: inline; color: inherit; }
    </style>
</head>
<body class="bg-ios-bg text-slate-900 h-screen w-screen overflow-hidden select-none">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo, Component } = React;

        // --- ERROR BOUNDARY ---
        class ErrorBoundary extends Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null };
            }
            static getDerivedStateFromError(error) { return { hasError: true, error }; }
            componentDidCatch(error, errorInfo) { console.error("React Error:", error, errorInfo); }
            render() {
                if (this.state.hasError) {
                    return (
                        <div className="flex flex-col items-center justify-center h-screen p-6 text-center">
                            <h2 className="text-xl font-bold text-red-500 mb-2">Something went wrong</h2>
                            <p className="text-gray-600 text-sm mb-4">{this.state.error?.message}</p>
                            <button onClick={() => window.location.reload()} className="bg-ios-blue text-white px-4 py-2 rounded-lg">Reload App</button>
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        // --- GEMINI API CONFIG ---
        const getEffectiveApiKey = () => localStorage.getItem('gemini_api_key') || '';

        // --- TEXT UTILS ---
        const chunkText = (text, maxLength = 3000) => {
            if (!text) return [];
            const chunks = [];
            let currentText = text.replace(/\s+/g, ' ').trim();
            while (currentText.length > 0) {
                if (currentText.length <= maxLength) {
                    chunks.push(currentText);
                    break;
                }
                let splitIndex = -1;
                const searchChars = ['. ', '? ', '! ', '; ', ' '];
                for(let char of searchChars) {
                    const idx = currentText.lastIndexOf(char, maxLength);
                    if(idx > maxLength * 0.6) {
                        splitIndex = idx;
                        break;
                    }
                }
                if (splitIndex === -1) splitIndex = maxLength; 
                chunks.push(currentText.substring(0, splitIndex + 1));
                currentText = currentText.substring(splitIndex + 1).trim();
            }
            return chunks;
        };

        const callGeminiTTS = async (text) => {
            const key = getEffectiveApiKey();
            if (!key) throw new Error("API Key missing");
            const safeText = text.length > 4000 ? text.substring(0, 4000) : text;
            
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-preview-tts:generateContent?key=${key}`;
            const payload = { 
                contents: [{ parts: [{ text: safeText }] }], 
                generationConfig: { 
                    responseModalities: ["AUDIO"], 
                    speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } } } 
                } 
            };
            
            const response = await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload) });
            
            if (!response.ok) {
                const err = await response.json().catch(() => ({}));
                throw new Error(err.error?.message || `API Error: ${response.status}`);
            }
            
            const data = await response.json();
            const inlineData = data.candidates?.[0]?.content?.parts?.[0]?.inlineData;
            
            if (!inlineData || !inlineData.data) throw new Error("No audio data returned");
            
            let sampleRate = 24000; 
            if (inlineData.mimeType) {
                const rateMatch = inlineData.mimeType.match(/rate=(\d+)/);
                if (rateMatch) sampleRate = parseInt(rateMatch[1], 10);
            }

            return { base64: inlineData.data, sampleRate };
        };

        const callGeminiSummary = async (text) => {
            const key = getEffectiveApiKey();
            if (!key) throw new Error("API Key missing");
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${key}`;
            const payload = { contents: [{ parts: [{ text: "Summarize this chapter concisely:\n\n" + text.substring(0, 10000) }] }] };
            const response = await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error("Summary API Error");
            const data = await response.json();
            return data.candidates?.[0]?.content?.parts?.[0]?.text || "No summary generated.";
        };

        // --- DB LAYER ---
        const DB_NAME = 'AudiobookManagerDB';
        const DB_VERSION = 2; 
        const openDB = () => new Promise((resolve, reject) => {
            const req = indexedDB.open(DB_NAME, DB_VERSION);
            req.onerror = () => reject('DB Error');
            req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('books')) db.createObjectStore('books', { keyPath: 'id' });
                if (!db.objectStoreNames.contains('files')) db.createObjectStore('files', { keyPath: 'id' });
            };
            req.onsuccess = (e) => resolve(e.target.result);
        });
        const dbOp = async (mode, store, cb) => {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(store, mode);
                const req = cb(tx.objectStore(store));
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        };
        const patchBook = async (bookId, updates) => {
            const db = await openDB();
            const tx = db.transaction('books', 'readwrite');
            const store = tx.objectStore('books');
            const book = await new Promise((resolve, reject) => { const req = store.get(bookId); req.onsuccess = () => resolve(req.result); req.onerror = () => reject(req.error); });
            if (!book) return;
            store.put({ ...book, ...updates });
            return new Promise(resolve => tx.oncomplete = resolve);
        };
        const saveFiles = async (files) => {
            const db = await openDB();
            const tx = db.transaction('files', 'readwrite');
            const store = tx.objectStore('files');
            files.forEach(f => store.put(f));
            return new Promise(resolve => tx.oncomplete = resolve);
        };

        const Icon = ({ name, size = 24, className = "" }) => {
            useEffect(() => lucide.createIcons(), [name]);
            return <i data-lucide={name} width={size} height={size} className={className}></i>;
        };

        const formatTime = (s) => {
            if (!s || isNaN(s)) return "0:00";
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return `${m}:${sec.toString().padStart(2, '0')}`;
        };

        // --- COMPONENTS ---

        const LoadingToast = ({ message, onCancel }) => (
            <div className="fixed bottom-24 left-1/2 transform -translate-x-1/2 z-[80] bg-black/80 backdrop-blur-md text-white px-6 py-3 rounded-full shadow-2xl flex items-center gap-3 animate-[slideUp_0.3s_ease-out] w-auto max-w-[90%]">
                <div className="animate-spin rounded-full h-4 w-4 border-2 border-white/30 border-t-white"></div>
                <span className="text-sm font-medium">{message}</span>
                {onCancel && <button onClick={onCancel} className="ml-2 bg-white/20 hover:bg-white/30 rounded-full p-1"><Icon name="x" size={14} /></button>}
            </div>
        );

        const SettingsModal = ({ onClose }) => {
            const [key, setKey] = useState(getEffectiveApiKey());
            const [status, setStatus] = useState("Test Browser Audio");

            const testAudio = async () => {
                setStatus("Playing...");
                try {
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    // iOS Unlock
                    if (ctx.state === 'suspended') await ctx.resume();
                    
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.frequency.value = 660;
                    osc.start();
                    gain.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.5);
                    osc.stop(ctx.currentTime + 0.5);
                    setTimeout(() => setStatus("Success!"), 500);
                } catch(e) {
                    setStatus("Failed: " + e.message);
                }
            };

            return (
                <div className="fixed inset-0 z-[70] flex items-center justify-center bg-black/40 backdrop-blur-sm p-4 animate-in fade-in">
                    <div className="bg-white rounded-2xl w-full max-w-sm p-6 shadow-2xl">
                        <h3 className="text-xl font-bold mb-4">Settings</h3>
                        <label className="block text-sm font-medium text-gray-700 mb-2">Google Gemini API Key</label>
                        <input type="password" value={key} onChange={e => setKey(e.target.value)} placeholder="AIzaSy..." className="w-full p-3 border rounded-xl bg-gray-50 mb-4 font-mono text-sm" />
                        
                        <div className="bg-gray-50 p-3 rounded-xl mb-6">
                            <button onClick={testAudio} className={`text-sm font-medium flex items-center gap-2 w-full justify-center py-2 rounded-lg transition ${status.includes('Success') ? 'bg-green-100 text-green-700' : 'text-ios-blue hover:bg-white shadow-sm'}`}>
                                <Icon name="volume-2" size={16} /> {status}
                            </button>
                        </div>

                        <div className="flex gap-3">
                            <button onClick={onClose} className="flex-1 py-2 text-gray-600 font-medium">Cancel</button>
                            <button onClick={() => { localStorage.setItem('gemini_api_key', key); onClose(); }} className="flex-1 py-2 bg-ios-blue text-white rounded-xl font-semibold">Save</button>
                        </div>
                    </div>
                </div>
            );
        };

        const AIModal = ({ type, content, onClose }) => {
            return (
                <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/40 backdrop-blur-sm p-6 animate-in fade-in">
                    <div className="bg-white rounded-2xl w-full max-w-lg shadow-2xl flex flex-col max-h-[80vh]">
                        <div className="p-4 border-b flex items-center gap-2"><Icon name={type === 'summary' ? 'sparkles' : 'mic'} className="text-ios-blue" /><h3 className="font-bold text-lg">{type === 'summary' ? 'Chapter Summary' : 'AI Narrator'}</h3></div>
                        <div className="p-6 overflow-y-auto">{content ? <p className="leading-relaxed text-gray-800 whitespace-pre-wrap">{content}</p> : <div className="flex flex-col items-center justify-center py-8"><div className="animate-spin rounded-full h-8 w-8 border-b-2 border-ios-blue mb-4"></div><p className="text-gray-500 animate-pulse">Consulting the AI...</p></div>}</div>
                        <div className="p-4 border-t bg-gray-50 rounded-b-2xl"><button onClick={onClose} className="w-full py-3 bg-white border border-gray-200 rounded-xl font-semibold text-gray-700 shadow-sm">Close</button></div>
                    </div>
                </div>
            );
        };

        const SplitOptions = ({ file, onSplitByTime, onSplitSilence, onCancel }) => {
            const [mins, setMins] = useState(5);
            return (
                <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/40 backdrop-blur-sm p-4 animate-in fade-in">
                    <div className="bg-white rounded-2xl w-full max-w-sm p-6 shadow-2xl">
                        <h3 className="text-xl font-bold mb-4">Split Track</h3>
                        <p className="text-sm text-gray-500 mb-4">Split large audio files into smaller parts for easier navigation.</p>
                        
                        <label className="block text-sm font-medium text-gray-700 mb-2">Split every (minutes)</label>
                        <input type="number" min="1" value={mins} onChange={e => setMins(e.target.value)} className="w-full p-3 border rounded-xl bg-gray-50 mb-6" />
                        
                        <div className="flex flex-col gap-2">
                            <button onClick={() => onSplitByTime(Number(mins))} className="w-full py-3 bg-ios-blue text-white rounded-xl font-semibold hover:bg-blue-600 transition">Split by Time</button>
                            <button onClick={onSplitSilence} className="w-full py-3 bg-gray-100 text-gray-800 rounded-xl font-semibold hover:bg-gray-200 transition">Split by Silence (Beta)</button>
                            <button onClick={onCancel} className="w-full py-2 text-gray-500 font-medium mt-2">Cancel</button>
                        </div>
                    </div>
                </div>
            );
        };

        const EpubReader = ({ bookId, onClose }) => {
            const viewerRef = useRef(null);
            const [book, setBook] = useState(null);
            const [rendition, setRendition] = useState(null);
            const [toc, setToc] = useState([]);
            const [progress, setProgress] = useState(0);
            const [ready, setReady] = useState(false);
            const [showTOC, setShowTOC] = useState(false);
            const [showAppearance, setShowAppearance] = useState(false);
            const [aiModal, setAiModal] = useState(null);
            const [summaryText, setSummaryText] = useState(null);
            const [isReadingAloud, setIsReadingAloud] = useState(false);
            const [audioStatus, setAudioStatus] = useState("");
            const [scanning, setScanning] = useState(false);
            const [isEditingTOC, setIsEditingTOC] = useState(false);
            
            // Audio State
            const audioCtx = useRef(null);
            const audioSource = useRef(null);
            const ttsQueue = useRef([]);
            const ttsIndex = useRef(0);

            const fontOptions = [
                { label: 'System UI', value: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif' },
                { label: 'Georgia', value: 'Georgia, serif' },
                { label: 'Times New Roman', value: '"Times New Roman", Times, serif' },
                { label: 'Verdana', value: 'Verdana, sans-serif' },
                { label: 'Helvetica', value: 'Helvetica, Arial, sans-serif' }
            ];

            const [settings, setSettings] = useState(() => {
                const saved = localStorage.getItem('reader_settings');
                return saved ? JSON.parse(saved) : {
                    theme: 'light',
                    fontSize: 100,
                    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                    lineHeight: 1.5,
                    dialogueEnhance: false,
                    textColor: '#000000'
                };
            });

            useEffect(() => { localStorage.setItem('reader_settings', JSON.stringify(settings)); }, [settings]);
            const updateSetting = (key, value) => setSettings(prev => ({ ...prev, [key]: value }));

            // Initialize AudioContext on Mount with iOS Fixes
            useEffect(() => {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx.current = new AudioContext();
                return () => {
                    if (audioCtx.current) audioCtx.current.close();
                };
            }, []);

            useEffect(() => {
                const init = async () => {
                    if (!bookId) return;
                    const bookMeta = await dbOp('readonly', 'books', s => s.get(bookId));
                    if (!bookMeta || !bookMeta.epubId) return;
                    const f = await dbOp('readonly', 'files', s => s.get(bookMeta.epubId));
                    if (!f) return;
                    
                    const newBook = ePub(f.data);
                    setBook(newBook);
                    const rend = newBook.renderTo(viewerRef.current, { width: "100%", height: "100%", flow: "paginated" });
                    setRendition(rend);

                    rend.hooks.content.register((contents) => {
                        const doc = contents.document;
                        const style = doc.createElement('style');
                        style.textContent = `.dialogue-text { display: inline; color: inherit; }`; 
                        doc.head.appendChild(style);

                        const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_TEXT, null, false);
                        const nodes = [];
                        while(walker.nextNode()) nodes.push(walker.currentNode);

                        const regex = /([“"”][^"”]*[”"“])|("[^"]*")/g; 

                        nodes.forEach(node => {
                            if (!node.nodeValue || node.parentElement.tagName === 'SCRIPT' || node.parentElement.tagName === 'STYLE') return;
                            const text = node.nodeValue;
                            if (!regex.test(text)) return;
                            regex.lastIndex = 0;
                            const fragment = doc.createDocumentFragment();
                            let lastIndex = 0;
                            let match;
                            while ((match = regex.exec(text)) !== null) {
                                if (match.index > lastIndex) fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                                const span = doc.createElement('span');
                                span.className = 'dialogue-text';
                                span.textContent = match[0];
                                span.style.textShadow = 'var(--dialogue-shadow, none)';
                                fragment.appendChild(span);
                                lastIndex = regex.lastIndex;
                            }
                            if (lastIndex < text.length) fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
                            node.parentNode.replaceChild(fragment, node);
                        });
                    });

                    const initialLocation = bookMeta.lastReadLocation || undefined;
                    await rend.display(initialLocation);
                    newBook.ready.then(() => newBook.locations.generate(1000)).then(() => setReady(true));
                    
                    if (bookMeta.customTOC) setToc(bookMeta.customTOC);
                    else {
                        newBook.loaded.navigation.then(nav => setToc(nav.toc));
                    }

                    rend.themes.register('light', { body: { background: '#fff' } });
                    rend.themes.register('sepia', { body: { background: '#f6f1d1' } });
                    rend.themes.register('dark', { body: { background: '#1c1c1e' } });
                    
                    rend.on('relocated', (location) => {
                        setProgress(Math.floor(location.start.percentage * 100));
                        patchBook(bookId, { lastReadLocation: location.start.cfi });
                    });
                };
                init();
                return () => stopAudio();
            }, [bookId]);

            useEffect(() => {
                if(rendition) {
                    rendition.themes.select(settings.theme);
                    rendition.themes.fontSize(settings.fontSize + '%');
                    rendition.themes.font(settings.fontFamily);
                    const shadowStyle = settings.dialogueEnhance ? '0 0 2px currentColor' : 'none';
                    rendition.themes.register('custom-styles', { 
                        'body': { 
                            'color': `${settings.textColor} !important`,
                            'line-height': `${settings.lineHeight} !important`,
                            '--dialogue-shadow': shadowStyle
                        }
                    });
                    rendition.themes.select('custom-styles');
                }
            }, [settings, rendition]);

            // --- PURE WEB AUDIO ENGINE ---

            const stopAudio = () => {
                if (audioSource.current) {
                    try { audioSource.current.stop(); } catch(e){}
                    audioSource.current = null;
                }
                setIsReadingAloud(false);
                setAudioStatus("");
                ttsQueue.current = [];
            };

            const playRawPCM = (base64, sampleRate) => {
                if (!audioCtx.current) return;
                
                const binaryString = window.atob(base64.replace(/\s/g, ''));
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
                
                const int16 = new Int16Array(bytes.buffer);
                const float32 = new Float32Array(int16.length);
                for (let i = 0; i < int16.length; i++) {
                    float32[i] = int16[i] / 32768.0; 
                }

                const audioBuffer = audioCtx.current.createBuffer(1, float32.length, sampleRate);
                audioBuffer.getChannelData(0).set(float32);

                const source = audioCtx.current.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioCtx.current.destination);
                
                audioSource.current = source;
                
                source.onended = () => {
                    ttsIndex.current++;
                    playNextChunk();
                };
                
                source.start();
            };

            const playNextChunk = async () => {
                if (!isReadingAloud) return; 
                if (ttsIndex.current >= ttsQueue.current.length) {
                    setIsReadingAloud(false);
                    setAudioStatus("");
                    return;
                }

                setAudioStatus("Requesting audio...");
                const text = ttsQueue.current[ttsIndex.current];
                
                try {
                    const { base64, sampleRate } = await callGeminiTTS(text);
                    setAudioStatus("Playing...");
                    playRawPCM(base64, sampleRate);
                } catch(e) {
                    console.error("Playback error", e);
                    setAudioStatus("");
                    setIsReadingAloud(false);
                    alert("Audio Error: " + e.message);
                }
            };

            // --- IMPROVED TEXT EXTRACTION ---
            const getVisibleText = () => {
                if (!rendition) return null;
                try {
                    const range = rendition.getRange(rendition.currentLocation().start.cfi, rendition.currentLocation().end.cfi);
                    return range ? range.toString() : null;
                } catch(e) { return null; }
            };

            const extractTextSafe = async () => {
                if (!rendition || !book) return null;
                
                // Strategy 1: Visible Text (Instant)
                const visible = getVisibleText();
                
                // Strategy 2: Full Chapter (Async, might fail/timeout)
                try {
                    const cfi = rendition.currentLocation().start.cfi;
                    const item = book.spine.get(cfi);
                    if (!item) return visible; 

                    const extractPromise = item.load(book.load.bind(book)).then(doc => {
                        return doc.body ? doc.body.innerText : (doc.documentElement ? doc.documentElement.innerText : "");
                    });
                    const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject("Timeout"), 2000));
                    
                    const fullText = await Promise.race([extractPromise, timeoutPromise]);
                    return fullText && fullText.length > 20 ? fullText : visible;
                } catch (e) {
                    console.warn("Full chapter extract failed, using visible text", e);
                    return visible;
                }
            };

            const handleTTS = async () => {
                if (isReadingAloud) { 
                    stopAudio();
                    return; 
                }
                
                // CRITICAL IOS FIX: Wake up audio engine IMMEDIATELY on click
                if (audioCtx.current) {
                    if(audioCtx.current.state === 'suspended') await audioCtx.current.resume();
                    const buffer = audioCtx.current.createBuffer(1, 1, 22050);
                    const source = audioCtx.current.createBufferSource();
                    source.buffer = buffer;
                    source.connect(audioCtx.current.destination);
                    source.start(0);
                }

                setIsReadingAloud(true);
                setAudioStatus("Analyzing text...");
                
                try {
                    const fullText = await extractTextSafe();

                    if (!fullText || fullText.trim().length < 5) {
                        alert("No text found. Try turning pages.");
                        setAudioStatus("");
                        setIsReadingAloud(false);
                        return;
                    }

                    // Calculate Start Position based on visible text
                    let startIdx = 0;
                    const visible = getVisibleText();
                    if (visible && visible.length > 20) {
                        const searchStr = visible.substring(0, 50).replace(/\s+/g, ' ').trim();
                        const normFull = fullText.replace(/\s+/g, ' ');
                        const found = normFull.indexOf(searchStr);
                        if (found !== -1) startIdx = found;
                    }

                    const chunks = chunkText(fullText.substring(startIdx));
                    if (chunks.length === 0) throw new Error("Text processing empty");

                    ttsQueue.current = chunks;
                    ttsIndex.current = 0;
                    playNextChunk();

                } catch (e) { 
                    alert("TTS Error: " + (e.message || e)); 
                    setIsReadingAloud(false); 
                    setAudioStatus("");
                }
            };

            const handleSummary = async () => {
                setAiModal('summary'); setSummaryText(null);
                try {
                    const text = await extractTextSafe();
                    if (!text || text.length < 50) throw new Error("Could not extract enough text.");
                    const summary = await callGeminiSummary(text);
                    setSummaryText(summary);
                } catch (e) { setSummaryText("Error: " + e.message); }
            };

            const handleSlider = (e) => {
                const val = e.target.value; setProgress(val);
                if (book && book.locations.length() > 0) { const cfi = book.locations.cfiFromPercentage(val / 100); rendition.display(cfi); }
            };
            const nav = (dir) => { if(rendition) dir === 'next' ? rendition.next() : rendition.prev(); };
            
            const scanChapters = async () => {
                if (!book) return;
                setScanning(true);
                const newToc = [];
                try {
                    for (let i = 0; i < book.spine.length; i++) {
                        const item = book.spine.get(i);
                        const doc = await item.load(book.load.bind(book));
                        const titleEl = doc.querySelector('h1, h2, h3, .title, .chapter');
                        let label = titleEl ? titleEl.innerText.trim() : "";
                        if(label) newToc.push({ label, href: item.href });
                    }
                    if (newToc.length > 0) { setToc(newToc); await patchBook(bookId, { customTOC: newToc }); }
                    else alert("No chapters detected.");
                } catch (e) { alert("Scan failed."); } finally { setScanning(false); }
            };
            const updateTocItem = (i, l) => { const n = [...toc]; n[i].label = l; setToc(n); };
            const saveTOC = async () => { await patchBook(bookId, { customTOC: toc }); setIsEditingTOC(false); };

            return (
                <div className={`fixed inset-0 z-50 flex flex-col ${settings.theme === 'dark' ? 'bg-[#1c1c1e] text-gray-200' : (settings.theme === 'sepia' ? 'bg-[#f6f1d1] text-[#5f4b32]' : 'bg-white text-gray-900')}`}>
                    <div className={`h-14 border-b flex items-center justify-between px-4 safe-top z-20 ${settings.theme === 'dark' ? 'border-gray-800' : 'border-gray-200 bg-white/50 backdrop-blur'}`}>
                        <button onClick={onClose} className="text-ios-blue font-semibold">Done</button>
                        <div className="flex gap-2">
                             <button onClick={handleTTS} className={`p-2 rounded-full ${isReadingAloud && !audioStatus.includes("Playing") ? 'bg-ios-blue text-white animate-pulse' : 'hover:bg-black/5'}`} title="AI Narrator"><Icon name="headphones" size={20} /></button>
                             <button onClick={handleSummary} className="p-2 rounded-full hover:bg-black/5" title="Summarize"><Icon name="sparkles" size={20} /></button>
                            <div className="w-px h-6 bg-gray-300 mx-1"></div>
                            <button onClick={() => { setShowAppearance(!showAppearance); setShowTOC(false); }} className="p-2 rounded-full hover:bg-black/5"><Icon name="type" size={20} /></button>
                            <button onClick={() => { setShowTOC(!showTOC); setShowAppearance(false); }} className="p-2 rounded-full hover:bg-black/5"><Icon name="list" size={20} /></button>
                        </div>
                    </div>

                    <div className="flex-1 relative overflow-hidden">
                        {!ready && <div className="absolute inset-0 flex flex-col items-center justify-center gap-2 z-10"><div className="animate-spin rounded-full h-8 w-8 border-b-2 border-ios-blue"></div><div className="text-xs opacity-50">Indexing Book...</div></div>}
                        <div ref={viewerRef} className="w-full h-full"></div>
                        <div className="absolute inset-y-0 left-0 w-20 z-0" onClick={() => nav('prev')}></div>
                        <div className="absolute inset-y-0 right-0 w-20 z-0" onClick={() => nav('next')}></div>
                    </div>

                    <div className={`h-16 border-t px-6 flex flex-col justify-center safe-bottom z-20 ${settings.theme === 'dark' ? 'border-gray-800 bg-[#1c1c1e]' : 'border-gray-200 bg-white'}`}>
                        <input type="range" min="0" max="100" step="1" value={progress} onChange={handleSlider} className="w-full h-1 bg-gray-300 rounded-full mb-1" />
                        <div className="flex justify-between text-[10px] opacity-50 font-mono"><span>{progress}%</span><span>{book?.locations?.total || '...'} locs</span></div>
                    </div>

                    {audioStatus && <LoadingToast message={audioStatus} onCancel={stopAudio} />}

                    {showTOC && (
                        <div className="absolute inset-0 top-14 bottom-16 bg-black/50 backdrop-blur-sm z-30" onClick={() => setShowTOC(false)}>
                            <div className={`absolute top-0 right-0 bottom-0 w-72 shadow-2xl overflow-y-auto animate-in slide-in-from-right flex flex-col ${settings.theme === 'dark' ? 'bg-[#2c2c2e]' : 'bg-white'}`} onClick={e => e.stopPropagation()}>
                                <div className="p-4 font-bold border-b border-gray-200/10 flex justify-between items-center">
                                    <span>Contents</span>
                                    <div className="flex gap-2">
                                        <button onClick={() => isEditingTOC ? saveTOC() : setIsEditingTOC(true)} className={`text-xs px-2 py-1 rounded ${isEditingTOC ? 'bg-ios-blue text-white' : 'bg-gray-200 text-gray-800'}`}>{isEditingTOC ? "Done" : "Edit"}</button>
                                        {!isEditingTOC && <button onClick={scanChapters} className="text-xs bg-gray-200 text-gray-800 px-2 py-1 rounded" disabled={scanning}>{scanning ? "Scanning..." : "Auto-Detect"}</button>}
                                    </div>
                                </div>
                                <div className="flex-1 overflow-y-auto">
                                    {toc.map((item, i) => (
                                        <div key={i} className="p-3 border-b border-gray-200/10 text-sm hover:bg-white/10 flex items-center">
                                            {isEditingTOC ? (
                                                <input type="text" value={item.label} onChange={(e) => updateTocItem(i, e.target.value)} className="w-full bg-transparent border-b border-gray-300 focus:outline-none focus:border-ios-blue py-1" />
                                            ) : (
                                                <div onClick={() => { rendition.display(item.href); setShowTOC(false); }} className="cursor-pointer w-full">{item.label}</div>
                                            )}
                                        </div>
                                    ))}
                                    {toc.length === 0 && !scanning && <div className="p-8 text-center text-gray-400 text-sm">No chapters found.<br/>Try Auto-Detect.</div>}
                                </div>
                            </div>
                        </div>
                    )}

                    {showAppearance && (
                        <div className="absolute inset-0 z-30" onClick={() => setShowAppearance(false)}>
                             <div className={`absolute top-16 right-4 w-72 rounded-xl shadow-2xl p-4 animate-in zoom-in-95 overflow-y-auto max-h-[80vh] ${settings.theme === 'dark' ? 'bg-[#2c2c2e] border border-gray-700' : 'bg-white border border-gray-200'}`} onClick={e => e.stopPropagation()}>
                                 <div className="flex justify-between bg-gray-200/20 rounded-lg p-1 mb-4">
                                     {['light', 'sepia', 'dark'].map(t => (
                                         <button key={t} onClick={() => updateSetting('theme', t)} className={`flex-1 py-2 rounded-md capitalize text-sm font-medium ${settings.theme === t ? 'bg-white shadow-sm text-black' : 'text-gray-500 hover:text-gray-900'}`} style={settings.theme === t && t === 'dark' ? {background: '#555', color: 'white'} : {}}>{t}</button>
                                     ))}
                                 </div>
                                 <div className="mb-4">
                                     <div className="text-xs uppercase font-bold opacity-50 mb-1">Font</div>
                                     <select value={settings.fontFamily} onChange={(e) => updateSetting('fontFamily', e.target.value)} className="w-full p-2 rounded-lg bg-gray-200/20 border-none text-sm">
                                         {fontOptions.map(f => <option key={f.value} value={f.value}>{f.label}</option>)}
                                     </select>
                                 </div>
                                 <div className="mb-4">
                                     <div className="text-xs uppercase font-bold opacity-50 mb-2">Line Spacing</div>
                                     <div className="flex bg-gray-200/20 rounded-lg p-1">
                                         {[1.2, 1.5, 1.8].map((lh, i) => (
                                             <button key={lh} onClick={() => updateSetting('lineHeight', lh)} className={`flex-1 py-1.5 rounded text-xs font-medium ${settings.lineHeight === lh ? 'bg-white shadow-sm' : ''}`}>{i === 0 ? 'Tight' : i === 1 ? 'Normal' : 'Wide'}</button>
                                         ))}
                                     </div>
                                 </div>
                                 <div className="flex items-center justify-between gap-4 mb-4">
                                     <button onClick={() => updateSetting('fontSize', Math.max(50, settings.fontSize - 10))} className="p-2 border rounded-lg border-gray-200/20"><Icon name="minus" size={16} /></button>
                                     <span className="text-sm font-mono w-12 text-center">{settings.fontSize}%</span>
                                     <button onClick={() => updateSetting('fontSize', Math.min(200, settings.fontSize + 10))} className="p-2 border rounded-lg border-gray-200/20"><Icon name="plus" size={16} /></button>
                                 </div>
                                 <div className="mb-4">
                                     <div className="text-xs uppercase font-bold opacity-50 mb-2">Text Color</div>
                                     <input type="color" value={settings.textColor} onChange={(e) => updateSetting('textColor', e.target.value)} className="w-full h-8 rounded cursor-pointer" />
                                 </div>
                                 <div className="border-t border-gray-200/10 pt-3 flex items-center justify-between">
                                     <span className="text-sm font-medium">Enhance Dialogue</span>
                                     <button onClick={() => updateSetting('dialogueEnhance', !settings.dialogueEnhance)} className={`w-12 h-6 rounded-full transition-colors relative ${settings.dialogueEnhance ? 'bg-ios-blue' : 'bg-gray-300'}`}><div className={`w-5 h-5 bg-white rounded-full absolute top-0.5 transition-transform ${settings.dialogueEnhance ? 'left-[26px]' : 'left-0.5'}`}></div></button>
                                 </div>
                             </div>
                         </div>
                    )}
                    
                    {aiModal === 'summary' && <AIModal type="summary" content={summaryText} onClose={() => setAiModal(null)} />}
                </div>
            );
        };

        const BookEditor = ({ bookId, onClose, onSave }) => {
            const [title, setTitle] = useState("Untitled Book");
            const [author, setAuthor] = useState("Unknown Author");
            const [coverId, setCoverId] = useState(null);
            const [coverPreview, setCoverPreview] = useState(null);
            const [epubId, setEpubId] = useState(null);
            const [tracks, setTracks] = useState([]);
            const [processing, setProcessing] = useState(false);
            const [status, setStatus] = useState("");
            const [splitTarget, setSplitTarget] = useState(null);

            useEffect(() => {
                if (!bookId) return;
                const load = async () => {
                    const book = await dbOp('readonly', 'books', s => s.get(bookId));
                    if (book) {
                        setTitle(book.title);
                        setAuthor(book.author);
                        setCoverId(book.coverId);
                        setEpubId(book.epubId);
                        const normalizedTracks = (book.tracks || []).map(t => ({
                            ...t,
                            fileId: t.fileId || t.id,
                            start: t.start || 0,
                            duration: t.duration || null 
                        }));
                        setTracks(normalizedTracks);
                        if (book.coverId) {
                            const f = await dbOp('readonly', 'files', s => s.get(book.coverId));
                            if (f) setCoverPreview(URL.createObjectURL(f.data));
                        }
                    }
                };
                load();
            }, [bookId]);

            const handleCoverUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                setCoverPreview(URL.createObjectURL(file));
                const id = crypto.randomUUID();
                setCoverId(id);
                await saveFiles([{ id, data: file, type: 'image' }]);
            };

            const handleEpubUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const id = crypto.randomUUID();
                setEpubId(id);
                await saveFiles([{ id, data: file, type: 'epub' }]);
            };

            const handleAddTracks = async (e) => {
                setProcessing(true);
                setStatus("Importing tracks...");
                const files = Array.from(e.target.files);
                const newFiles = [];
                const newTracks = [];
                for (let f of files) {
                    if (f.name.endsWith('.mp3') || f.name.endsWith('.wav') || f.name.endsWith('.m4a') || f.type.startsWith('audio/')) {
                        const id = crypto.randomUUID();
                        newFiles.push({ id, data: f, type: 'audio' });
                        newTracks.push({ id, fileId: id, name: f.name, start: 0, duration: null });
                    }
                }
                await saveFiles(newFiles);
                setTracks(prev => [...prev, ...newTracks]);
                setProcessing(false);
            };

            const openSplitMenu = async (idx) => {
                const track = tracks[idx];
                const fileRec = await dbOp('readonly', 'files', s => s.get(track.fileId));
                if (!fileRec) return;
                setSplitTarget({ idx, track, file: fileRec.data });
            };

            const executeSplitByTime = async (minutes) => {
                const { idx, track, file } = splitTarget;
                setSplitTarget(null);
                setProcessing(true);
                setStatus("Calculating Duration...");
                try {
                    const audio = document.createElement('audio');
                    audio.muted = true;
                    const url = URL.createObjectURL(file);
                    audio.src = url;
                    await new Promise(r => audio.onloadedmetadata = r);
                    const duration = audio.duration;
                    URL.revokeObjectURL(url);

                    const chunkSeconds = minutes * 60;
                    const parts = Math.ceil(duration / chunkSeconds);
                    const newTracks = [];
                    for (let i = 0; i < parts; i++) {
                        const start = i * chunkSeconds;
                        const end = Math.min((i + 1) * chunkSeconds, duration);
                        newTracks.push({
                            id: crypto.randomUUID(),
                            fileId: track.fileId,
                            name: `${track.name} - Part ${i + 1}`,
                            start: start,
                            duration: end - start
                        });
                    }
                    const updated = [...tracks];
                    updated.splice(idx, 1, ...newTracks);
                    setTracks(updated);
                    setStatus(`Split into ${parts} parts!`);
                } catch(e) { alert("Error splitting file."); } finally { setProcessing(false); setTimeout(() => setStatus(""), 2000); }
            };

            const executeSplitSilence = async () => {
                alert("Please use Time Split for large files.");
                setSplitTarget(null);
            };

            const sortTracks = () => {
                const sorted = [...tracks].sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
                setTracks(sorted);
            };

            const shuffleTracks = () => {
                setTracks(prev => {
                    const shuffled = [...prev];
                    for (let i = shuffled.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                    }
                    return shuffled;
                });
            };

            const removeTrack = (idx) => { setTracks(prev => prev.filter((_, i) => i !== idx)); };

            const handleSave = async () => {
                const id = bookId || crypto.randomUUID();
                let currentTrackIndex = 0;
                let currentTime = 0;
                if (bookId) {
                    const old = await dbOp('readonly', 'books', s => s.get(bookId));
                    if (old) { currentTrackIndex = old.currentTrackIndex; currentTime = old.currentTime; }
                }
                const book = { id, title, author, coverId, epubId, tracks, updatedAt: Date.now(), currentTrackIndex, currentTime };
                await dbOp('readwrite', 'books', s => s.put(book));
                onSave();
            };

            return (
                <div className="fixed inset-0 z-50 bg-ios-bg flex flex-col animate-in slide-in-from-bottom duration-300">
                    <div className="bg-white/90 backdrop-blur border-b border-ios-border px-4 py-3 flex justify-between items-center safe-top">
                        <button onClick={onClose} className="text-ios-blue font-medium">Cancel</button>
                        <span className="font-semibold">Edit Book</span>
                        <button onClick={handleSave} className="text-ios-blue font-bold">Save</button>
                    </div>

                    <div className="flex-1 overflow-y-auto p-4 pb-20 safe-bottom">
                        <div className="flex gap-4 mb-6">
                            <div className="w-28 h-28 bg-gray-200 rounded-lg flex-shrink-0 relative overflow-hidden group shadow-sm">
                                {coverPreview ? <img src={coverPreview} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center text-gray-400"><Icon name="image" /></div>}
                                <label className="absolute inset-0 bg-black/20 flex items-center justify-center opacity-0 group-hover:opacity-100 transition cursor-pointer">
                                    <span className="text-white text-xs font-bold bg-black/50 px-2 py-1 rounded">Edit</span>
                                    <input type="file" accept="image/*" className="hidden" onChange={handleCoverUpload} />
                                </label>
                            </div>
                            <div className="flex-1 space-y-3">
                                <input type="text" placeholder="Title" value={title} onChange={e => setTitle(e.target.value)} className="w-full bg-white p-2 rounded-lg border border-gray-200 text-lg font-semibold" />
                                <input type="text" placeholder="Author" value={author} onChange={e => setAuthor(e.target.value)} className="w-full bg-white p-2 rounded-lg border border-gray-200 text-gray-600" />
                            </div>
                        </div>

                        <div className="bg-white rounded-xl shadow-sm p-4 mb-6 flex items-center justify-between">
                            <div className="flex items-center gap-3">
                                <div className={`p-2 rounded-lg ${epubId ? 'bg-green-100 text-green-600' : 'bg-gray-100 text-gray-400'}`}><Icon name="book" size={20} /></div>
                                <div><h4 className="font-medium">E-Book File</h4><p className="text-xs text-gray-500">{epubId ? "EPUB Loaded" : "No EPUB uploaded"}</p></div>
                            </div>
                            <label className="text-sm font-medium text-ios-blue cursor-pointer bg-blue-50 px-3 py-1.5 rounded-full">{epubId ? "Change" : "Upload"}
                                <input type="file" accept=".epub,application/epub+zip" className="hidden" onChange={handleEpubUpload} />
                            </label>
                        </div>

                        <div className="mb-2 flex items-center justify-between px-1">
                            <h3 className="font-bold text-gray-500 uppercase tracking-wide text-xs">Audio Tracks ({tracks.length})</h3>
                            <div className="flex gap-2">
                                <button onClick={shuffleTracks} className="text-ios-blue text-xs font-medium">Shuffle</button>
                                <button onClick={sortTracks} className="text-ios-blue text-xs font-medium">Sort by Name</button>
                            </div>
                        </div>

                        <div className="bg-white rounded-xl shadow-sm overflow-hidden">
                            {tracks.length === 0 ? <div className="p-6 text-center text-gray-400 text-sm">No tracks yet.</div> : (
                                <div className="divide-y divide-gray-100">
                                    {tracks.map((t, idx) => (
                                        <div key={idx} className="p-3 flex items-center gap-3">
                                            <span className="text-gray-400 text-xs font-mono w-5">{idx + 1}</span>
                                            <div className="flex-1 min-w-0"><div className="truncate text-sm text-gray-800 font-medium">{t.name}</div><div className="text-xs text-gray-400">{t.start > 0 ? `Start: ${formatTime(t.start)}` : 'Full File'}{t.duration && ` • ${formatTime(t.duration)}`}</div></div>
                                            {(!t.duration || t.duration > 120) && <button onClick={() => openSplitMenu(idx)} className="text-gray-400 bg-gray-50 p-2 rounded-full hover:bg-ios-blue hover:text-white transition"><Icon name="scissors" size={16} /></button>}
                                            <button onClick={() => removeTrack(idx)} className="text-red-400 p-2 rounded-full hover:bg-red-50"><Icon name="minus-circle" size={16} /></button>
                                        </div>
                                    ))}
                                </div>
                            )}
                            <div className="p-3 bg-gray-50 border-t border-gray-100">
                                {processing ? <div className="flex flex-col items-center justify-center py-2 gap-2"><div className="animate-spin rounded-full h-5 w-5 border-b-2 border-ios-blue"></div><div className="text-xs text-gray-500">{status}</div></div> : (
                                    <label className="flex items-center justify-center gap-2 text-ios-blue font-semibold cursor-pointer w-full py-2"><Icon name="plus-circle" size={20} /> Add Audio Files
                                        <input type="file" multiple accept=".mp3,.wav,.m4a,audio/*" className="hidden" onChange={handleAddTracks} />
                                    </label>
                                )}
                            </div>
                        </div>
                    </div>
                    {splitTarget && <SplitOptions file={splitTarget.file} onSplitByTime={executeSplitByTime} onSplitSilence={executeSplitSilence} onCancel={() => setSplitTarget(null)} />}
                </div>
            );
        };

        const Player = ({ bookId, onBack }) => {
            const audioRef = useRef(null);
            const [book, setBook] = useState(null);
            const [cover, setCover] = useState(null);
            const [playing, setPlaying] = useState(false);
            const [time, setTime] = useState(0);
            const [dur, setDur] = useState(0); 
            const [showList, setShowList] = useState(false);
            const [showReader, setShowReader] = useState(false);
            const [isLoadingTrack, setIsLoadingTrack] = useState(false);
            const activeFileId = useRef(null);
            const hasInitializedAudio = useRef(false);

            // Effect 1: Load Book Data
            useEffect(() => {
                let mounted = true;
                const load = async () => {
                    try {
                        const b = await dbOp('readonly', 'books', s => s.get(bookId));
                        if(mounted && b) {
                            if (!b.tracks) b.tracks = []; // Safety
                            setBook(b);
                            if (b.coverId) {
                                const f = await dbOp('readonly', 'files', s => s.get(b.coverId));
                                if(f && mounted) setCover(URL.createObjectURL(f.data));
                            }
                        }
                    } catch (e) {
                        console.error("Failed to load book", e);
                    }
                };
                load();
                return () => { mounted = false; };
            }, [bookId]);

            // Effect 2: Initialize Audio (Only when book AND ref are ready)
            useEffect(() => {
                if (book && audioRef.current && book.tracks.length > 0 && !hasInitializedAudio.current) {
                     hasInitializedAudio.current = true;
                     loadTrack(book, book.currentTrackIndex || 0, false);
                }
            }, [book]);

            const loadTrack = async (b, index, autoPlay) => {
                const track = b.tracks[index];
                if (!track) return;
                
                setIsLoadingTrack(true);
                const fileId = track.fileId || track.id;
                const startTime = track.start || 0;
                
                try {
                    if (activeFileId.current !== fileId) {
                        const f = await dbOp('readonly', 'files', s => s.get(fileId));
                        if (f && audioRef.current) {
                            const url = URL.createObjectURL(f.data);
                            audioRef.current.src = url;
                            audioRef.current.load(); // Required for iOS
                            activeFileId.current = fileId;
                            audioRef.current.currentTime = (index === b.currentTrackIndex) ? (b.currentTime || startTime) : startTime;
                        }
                    } else if (audioRef.current) {
                        // Check buffer logic
                        const buffer = 1; 
                        if (audioRef.current.currentTime < startTime - buffer || audioRef.current.currentTime > (track.start + (track.duration||99999))) {
                            audioRef.current.currentTime = startTime;
                        }
                    }
                } catch(e) {
                    console.error("Error loading track", e);
                }
                
                setIsLoadingTrack(false);
                if (autoPlay) { 
                    togglePlay(true);
                }
            };

            const togglePlay = async (shouldPlay) => {
                if (!audioRef.current) return;
                
                try {
                    if (shouldPlay) {
                        await audioRef.current.play();
                        setPlaying(true);
                    } else {
                        audioRef.current.pause();
                        setPlaying(false);
                    }
                } catch (e) {
                    console.error("Playback error", e);
                    setPlaying(false);
                    if (e.name === 'NotAllowedError') {
                        alert("Tap Play to start audio (iOS requires user interaction).");
                    }
                }
            };

            const updateBookProgress = (t) => {
                if (!bookId) return;
                patchBook(bookId, { currentTime: t });
            };

            const changeTrack = async (idx) => {
                const b = { ...book, currentTrackIndex: idx };
                const t = b.tracks[idx];
                b.currentTime = t.start || 0; 
                setBook(b);
                await loadTrack(b, idx, true);
                patchBook(bookId, { currentTrackIndex: idx, currentTime: b.currentTime });
            };

            const handleTimeUpdate = () => {
                const ct = audioRef.current.currentTime;
                setTime(ct);
                setDur(audioRef.current.duration);
                updateBookProgress(ct);

                if (book && book.tracks[book.currentTrackIndex]) {
                    const current = book.tracks[book.currentTrackIndex];
                    const endTime = (current.start || 0) + (current.duration || 999999);
                    
                    if (current.duration && ct >= endTime - 0.2) {
                        if (book.currentTrackIndex < book.tracks.length - 1) {
                            const nextIndex = book.currentTrackIndex + 1;
                            const nextTrack = book.tracks[nextIndex];
                            setBook(prev => ({ ...prev, currentTrackIndex: nextIndex }));
                            
                            if ((nextTrack.fileId || nextTrack.id) === (current.fileId || current.id)) {
                                patchBook(bookId, { currentTrackIndex: nextIndex });
                            } else {
                                changeTrack(nextIndex);
                            }
                        } else {
                            setPlaying(false);
                        }
                    }
                }
            };

            if (!book) return <div className="h-full flex items-center justify-center"><div className="animate-spin rounded-full h-8 w-8 border-b-2 border-ios-blue"></div></div>;

            const currentTrack = book.tracks[book.currentTrackIndex];
            const trackStart = currentTrack?.start || 0;
            const trackDur = currentTrack?.duration || dur;
            const sliderVal = time - trackStart;
            
            return (
                <div className="h-full flex flex-col bg-ios-bg">
                    <div className="safe-top px-4 pt-4 flex justify-between items-center z-10">
                        <button onClick={onBack} className="p-2 text-gray-500"><Icon name="chevron-down" /></button>
                        <span className="text-xs font-bold text-gray-400 uppercase tracking-widest">Now Playing</span>
                        <div className="w-8"></div>
                    </div>

                    <div className="flex-1 flex flex-col items-center justify-center p-8 space-y-8">
                        <div className={`w-full max-w-xs aspect-square rounded-2xl shadow-ios-float overflow-hidden bg-gray-200 transform transition-transform duration-500 ${playing ? 'scale-105' : 'scale-100'}`}>
                            {cover ? <img src={cover} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center text-gray-400"><Icon name="music" size={64} /></div>}
                        </div>

                        <div className="text-center w-full max-w-sm">
                            <h2 className="text-2xl font-bold truncate px-4">{book.title}</h2>
                            <p className="text-gray-500">{book.author}</p>
                            <div className="bg-blue-100 text-ios-blue text-xs font-bold px-3 py-1 rounded-full inline-block mt-2 truncate max-w-full">
                                {currentTrack?.name || "No Track"}
                            </div>
                        </div>

                        <div className="w-full max-w-sm px-4">
                            <input 
                                type="range" 
                                min="0" max={trackDur || 1} 
                                value={Math.max(0, sliderVal)} 
                                onChange={(e) => { 
                                    const seekTime = Number(e.target.value) + trackStart;
                                    if(audioRef.current) {
                                        audioRef.current.currentTime = seekTime; 
                                        setTime(seekTime);
                                    } 
                                }}
                                className="w-full h-1 bg-gray-300 rounded-full"
                            />
                            <div className="flex justify-between text-xs text-gray-400 mt-2 font-mono">
                                <span>{formatTime(sliderVal)}</span>
                                <span>-{formatTime(trackDur - sliderVal)}</span>
                            </div>
                        </div>

                        <div className="flex items-center justify-between w-full max-w-xs px-6">
                            <button onClick={() => { if(audioRef.current) audioRef.current.currentTime -= 30; }} className="text-gray-800 flex flex-col items-center gap-1">
                                <Icon name="rotate-ccw" size={32} /> <span className="text-[10px] font-bold">30</span>
                            </button>
                            <button 
                                onClick={() => togglePlay(!playing)} 
                                disabled={isLoadingTrack}
                                className={`w-20 h-20 bg-slate-900 text-white rounded-full flex items-center justify-center shadow-lg active:scale-95 transition ${isLoadingTrack ? 'opacity-50' : ''}`}
                            >
                                {isLoadingTrack ? (
                                    <div className="animate-spin rounded-full h-8 w-8 border-2 border-white/30 border-t-white"></div>
                                ) : (
                                    <Icon name={playing ? "pause" : "play"} size={36} className="ml-1 fill-current" />
                                )}
                            </button>
                            <button onClick={() => { if(audioRef.current) audioRef.current.currentTime += 300; }} className="text-gray-800 flex flex-col items-center gap-1">
                                <Icon name="rotate-cw" size={32} /> <span className="text-[10px] font-bold">5m</span>
                            </button>
                        </div>
                    </div>

                    {book.epubId && (
                        <div className="safe-bottom pb-8 flex justify-center">
                             <button onClick={() => setShowReader(true)} className="flex items-center gap-2 bg-white px-5 py-3 rounded-full shadow-md text-sm font-bold text-gray-800">
                                <Icon name="book-open" size={18} /> Read Along
                            </button>
                        </div>
                    )}
                    
                    {showReader && <EpubReader bookId={bookId} onClose={() => setShowReader(false)} />}
                    
                    <audio 
                        ref={audioRef} 
                        onTimeUpdate={handleTimeUpdate} 
                        onEnded={() => { if(book.currentTrackIndex >= book.tracks.length - 1) setPlaying(false); }}
                        onError={(e) => console.log("Audio Error", e)}
                    />
                </div>
            );
        };

        const App = () => {
            const [view, setView] = useState('library'); 
            const [activeBookId, setActiveBookId] = useState(null);
            const [editingBookId, setEditingBookId] = useState(null);
            const [isEditing, setIsEditing] = useState(false);
            const [showSettings, setShowSettings] = useState(false);
            const [books, setBooks] = useState([]);
            const [covers, setCovers] = useState({});

            const loadLibrary = async () => {
                const list = await dbOp('readonly', 'books', s => s.getAll());
                setBooks(list);
                list.forEach(async b => {
                    if (b.coverId && !covers[b.id]) {
                        const f = await dbOp('readonly', 'files', s => s.get(b.coverId));
                        if(f) setCovers(prev => ({...prev, [b.id]: URL.createObjectURL(f.data)}));
                    }
                });
            };

            useEffect(() => { loadLibrary(); }, []);

            return (
                <ErrorBoundary>
                    {view === 'library' && (
                        <div className="h-full bg-ios-bg p-6 safe-top overflow-y-auto">
                            <header className="flex justify-between items-center mb-6">
                                <h1 className="text-3xl font-bold tracking-tight">Library</h1>
                                <div className="flex gap-2">
                                    <button onClick={() => setShowSettings(true)} className="bg-white text-gray-600 rounded-full p-2 shadow-sm border active:scale-95 transition">
                                        <Icon name="settings" size={20} />
                                    </button>
                                    <button onClick={() => { setEditingBookId(null); setIsEditing(true); }} className="bg-ios-blue text-white rounded-full p-2 shadow-lg active:scale-95 transition">
                                        <Icon name="plus" size={20} />
                                    </button>
                                </div>
                            </header>

                            <div className="grid grid-cols-2 gap-4 pb-20">
                                {books.map(b => (
                                    <div key={b.id} onClick={() => { setActiveBookId(b.id); setView('player'); }} className="relative group cursor-pointer">
                                        <div className="aspect-square bg-white rounded-xl shadow-ios overflow-hidden mb-2 relative">
                                            {covers[b.id] ? <img src={covers[b.id]} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center bg-gray-100 text-gray-300"><Icon name="music" size={40} /></div>}
                                            <button 
                                                onClick={(e) => { e.stopPropagation(); setEditingBookId(b.id); setIsEditing(true); }}
                                                className="absolute top-2 right-2 bg-white/90 p-1.5 rounded-full shadow-sm opacity-0 group-hover:opacity-100 transition text-gray-700 hover:text-blue-600"
                                            >
                                                <Icon name="pencil" size={16} />
                                            </button>
                                        </div>
                                        <h3 className="font-semibold text-sm truncate leading-tight">{b.title}</h3>
                                        <p className="text-xs text-gray-500 truncate">{b.author}</p>
                                    </div>
                                ))}
                                {books.length === 0 && <div className="col-span-2 text-center text-gray-400 mt-20">Tap + to create a book</div>}
                            </div>
                        </div>
                    )}

                    {view === 'player' && <Player bookId={activeBookId} onBack={() => setView('library')} />}
                    
                    {isEditing && (
                        <BookEditor 
                            bookId={editingBookId} 
                            onClose={() => setIsEditing(false)} 
                            onSave={() => { setIsEditing(false); loadLibrary(); }} 
                        />
                    )}

                    {showSettings && <SettingsModal onClose={() => setShowSettings(false)} />}
                </ErrorBoundary>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
