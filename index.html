<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#F2F2F7">
    <title>Audiobook Manager</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- EPUB.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { sans: ['-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'sans-serif'] },
                    colors: {
                        ios: { bg: '#F2F2F7', card: '#FFFFFF', blue: '#007AFF', red: '#FF3B30', gray: '#8E8E93', border: '#C6C6C8' }
                    },
                    boxShadow: { 'ios': '0 2px 12px rgba(0,0,0,0.06)', 'ios-float': '0 8px 30px rgba(0,0,0,0.12)' }
                }
            }
        }
    </script>
    <style>
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .safe-top { padding-top: max(env(safe-area-inset-top), 20px); }
        .safe-bottom { padding-bottom: max(env(safe-area-inset-bottom), 20px); }
        /* Range Input */
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 24px; width: 24px; border-radius: 50%;
            background: #fff; box-shadow: 0 2px 6px rgba(0,0,0,0.3); margin-top: -10px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: rgba(0,0,0,0.1); border-radius: 2px;
        }
    </style>
</head>
<body class="bg-ios-bg text-slate-900 h-screen w-screen overflow-hidden select-none">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // --- DB LAYER ---
        const DB_NAME = 'AudiobookManagerDB';
        const DB_VERSION = 2; 

        const openDB = () => new Promise((resolve, reject) => {
            const req = indexedDB.open(DB_NAME, DB_VERSION);
            req.onerror = () => reject('DB Error');
            req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('books')) db.createObjectStore('books', { keyPath: 'id' });
                if (!db.objectStoreNames.contains('files')) db.createObjectStore('files', { keyPath: 'id' });
            };
            req.onsuccess = (e) => resolve(e.target.result);
        });

        const dbOp = async (mode, store, cb) => {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(store, mode);
                const req = cb(tx.objectStore(store));
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        };

        // Atomic Patch Function to prevent Audio/Reader overwrite conflicts
        const patchBook = async (bookId, updates) => {
            const db = await openDB();
            const tx = db.transaction('books', 'readwrite');
            const store = tx.objectStore('books');
            
            // Get current state
            const book = await new Promise((resolve, reject) => {
                const req = store.get(bookId);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });

            if (!book) return;

            // Merge updates
            const updatedBook = { ...book, ...updates };
            store.put(updatedBook);
            
            return new Promise(resolve => tx.oncomplete = resolve);
        };

        const saveFiles = async (files) => {
            const db = await openDB();
            const tx = db.transaction('files', 'readwrite');
            const store = tx.objectStore('files');
            files.forEach(f => store.put(f));
            return new Promise(resolve => tx.oncomplete = resolve);
        };

        const Icon = ({ name, size = 24, className = "" }) => {
            useEffect(() => lucide.createIcons(), [name]);
            return <i data-lucide={name} width={size} height={size} className={className}></i>;
        };

        const formatTime = (s) => {
            if (!s || isNaN(s)) return "0:00";
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return `${m}:${sec.toString().padStart(2, '0')}`;
        };

        // --- COMPONENTS ---

        // 1. SPLIT OPTIONS MODAL
        const SplitOptions = ({ file, onSplitByTime, onSplitSilence, onCancel }) => {
            const isLarge = file.size > 60 * 1024 * 1024; // 60MB Threshold

            return (
                <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/40 backdrop-blur-sm p-4 animate-in fade-in">
                    <div className="bg-white rounded-2xl w-full max-w-sm overflow-hidden shadow-2xl scale-100 animate-in zoom-in-95 duration-200">
                        <div className="p-6 pb-4">
                            <h3 className="text-xl font-bold mb-2">Split Audio</h3>
                            <p className="text-gray-500 text-sm mb-4">
                                "{file.name}"
                                {isLarge && <span className="block mt-2 text-amber-600 font-medium bg-amber-50 p-2 rounded-lg">⚠️ File is large ({(file.size/1024/1024).toFixed(0)}MB). Silence detection may crash browser. Recommended: Split by Time.</span>}
                            </p>
                            <div className="space-y-3">
                                <button onClick={() => onSplitByTime(30)} className="w-full bg-gray-50 hover:bg-gray-100 p-3 rounded-xl flex items-center justify-between group">
                                    <div className="flex flex-col items-start">
                                        <span className="font-semibold text-gray-800">Every 30 Minutes</span>
                                        <span className="text-xs text-gray-400">Instant • Zero Memory</span>
                                    </div>
                                    <Icon name="clock" className="text-gray-400 group-hover:text-blue-500" />
                                </button>
                                <button onClick={() => onSplitByTime(60)} className="w-full bg-gray-50 hover:bg-gray-100 p-3 rounded-xl flex items-center justify-between group">
                                    <div className="flex flex-col items-start">
                                        <span className="font-semibold text-gray-800">Every 1 Hour</span>
                                        <span className="text-xs text-gray-400">Instant • Zero Memory</span>
                                    </div>
                                    <Icon name="clock" className="text-gray-400 group-hover:text-blue-500" />
                                </button>
                                <button onClick={onSplitSilence} className={`w-full p-3 rounded-xl flex items-center justify-between group ${isLarge ? 'bg-red-50 hover:bg-red-100' : 'bg-purple-50 hover:bg-purple-100'}`}>
                                    <div className="flex flex-col items-start">
                                        <span className={`font-semibold ${isLarge ? 'text-red-700' : 'text-purple-700'}`}>Silence Detection</span>
                                        <span className={`text-xs ${isLarge ? 'text-red-500' : 'text-purple-500'}`}>{isLarge ? 'High Crash Risk' : 'Scans for gaps > 2s'}</span>
                                    </div>
                                    <Icon name="wand-2" className={`${isLarge ? 'text-red-400' : 'text-purple-400'}`} />
                                </button>
                            </div>
                        </div>
                        <div className="bg-gray-50 p-3 text-center border-t border-gray-100">
                            <button onClick={onCancel} className="text-ios-blue font-semibold w-full h-full">Cancel</button>
                        </div>
                    </div>
                </div>
            );
        };

        // 2. EPUB READER (With Persistent Location)
        const EpubReader = ({ bookId, onClose }) => {
            const viewerRef = useRef(null);
            const [book, setBook] = useState(null);
            const [rendition, setRendition] = useState(null);
            const [toc, setToc] = useState([]);
            const [progress, setProgress] = useState(0);
            const [ready, setReady] = useState(false);
            const [showTOC, setShowTOC] = useState(false);
            const [showAppearance, setShowAppearance] = useState(false);

            // Appearance State
            const [theme, setTheme] = useState('light'); // light, sepia, dark
            const [fontSize, setFontSize] = useState(100);
            const [fontFamily, setFontFamily] = useState('sans-serif');
            const [highlightColor, setHighlightColor] = useState('none'); 

            const themes = {
                light: { body: { color: '#000', background: '#fff' } },
                sepia: { body: { color: '#5f4b32', background: '#f6f1d1' } },
                dark: { body: { color: '#d1d1d1', background: '#1c1c1e' } }
            };

            const getHighlightColorCode = (colorName, currentTheme) => {
                if (colorName === 'none') return 'inherit';
                const isDark = currentTheme === 'dark';
                const colors = {
                    blue: isDark ? '#60a5fa' : '#2563eb',   
                    red: isDark ? '#f87171' : '#dc2626',
                    purple: isDark ? '#c084fc' : '#9333ea',
                };
                return colors[colorName] || 'inherit';
            };

            useEffect(() => {
                const init = async () => {
                    if (!bookId) return;
                    
                    // 1. Fetch Metadata
                    const bookMeta = await dbOp('readonly', 'books', s => s.get(bookId));
                    if (!bookMeta || !bookMeta.epubId) return;

                    // 2. Fetch File
                    const f = await dbOp('readonly', 'files', s => s.get(bookMeta.epubId));
                    if (!f) return;
                    
                    const newBook = ePub(f.data);
                    setBook(newBook);
                    
                    const rend = newBook.renderTo(viewerRef.current, { 
                        width: "100%", 
                        height: "100%", 
                        flow: "paginated" 
                    });
                    setRendition(rend);

                    // 3. Register Quote Hook
                    rend.hooks.content.register((contents) => {
                        const doc = contents.document;
                        const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_TEXT, null, false);
                        const nodes = [];
                        while(walker.nextNode()) nodes.push(walker.currentNode);

                        nodes.forEach(node => {
                            if (!node.nodeValue) return;
                            const regex = /([“"”][^"”]*[”"“])/g;
                            if (regex.test(node.nodeValue)) {
                                const fragment = doc.createDocumentFragment();
                                let lastIndex = 0;
                                node.nodeValue.replace(regex, (match, offset) => {
                                    const before = node.nodeValue.substring(lastIndex, arguments[arguments.length - 2]); 
                                    if(before) fragment.appendChild(document.createTextNode(before));
                                    const span = doc.createElement('span');
                                    span.className = 'dialogue-text';
                                    span.textContent = match;
                                    fragment.appendChild(span);
                                    lastIndex = arguments[arguments.length - 2] + match.length;
                                    return match;
                                });
                                const after = node.nodeValue.substring(lastIndex);
                                if(after) fragment.appendChild(document.createTextNode(after));
                                node.parentNode.replaceChild(fragment, node);
                            }
                        });
                    });

                    // 4. Display at Last Saved Location
                    const initialLocation = bookMeta.lastReadLocation || undefined;
                    await rend.display(initialLocation);
                    
                    newBook.ready.then(() => newBook.locations.generate(1000)).then(() => setReady(true));
                    const navigation = await newBook.loaded.navigation;
                    setToc(navigation.toc);

                    rend.themes.register('light', themes.light);
                    rend.themes.register('sepia', themes.sepia);
                    rend.themes.register('dark', themes.dark);
                    
                    // 5. Save Location on Move
                    rend.on('relocated', (location) => {
                        setProgress(Math.floor(location.start.percentage * 100));
                        // Atomic patch to avoid overwriting audio progress
                        patchBook(bookId, { lastReadLocation: location.start.cfi });
                    });
                };
                init();
            }, [bookId]);

            useEffect(() => {
                if(rendition) {
                    rendition.themes.select(theme);
                    rendition.themes.fontSize(fontSize + '%');
                    rendition.themes.font(fontFamily);
                    const colorCode = getHighlightColorCode(highlightColor, theme);
                    rendition.themes.register('highlights', { '.dialogue-text': { 'color': colorCode } });
                    rendition.themes.select('highlights');
                }
            }, [theme, fontSize, fontFamily, highlightColor, rendition]);

            const handleSlider = (e) => {
                const val = e.target.value;
                setProgress(val);
                if (book && book.locations.length() > 0) {
                    const cfi = book.locations.cfiFromPercentage(val / 100);
                    rendition.display(cfi);
                }
            };

            const nav = (dir) => { if(rendition) dir === 'next' ? rendition.next() : rendition.prev(); };

            return (
                <div className={`fixed inset-0 z-50 flex flex-col ${theme === 'dark' ? 'bg-[#1c1c1e] text-gray-200' : (theme === 'sepia' ? 'bg-[#f6f1d1] text-[#5f4b32]' : 'bg-white text-gray-900')}`}>
                    <div className={`h-14 border-b flex items-center justify-between px-4 safe-top z-20 ${theme === 'dark' ? 'border-gray-800' : 'border-gray-200 bg-white/50 backdrop-blur'}`}>
                        <button onClick={onClose} className="text-ios-blue font-semibold">Done</button>
                        <div className="flex gap-4">
                            <button onClick={() => { setShowAppearance(!showAppearance); setShowTOC(false); }} className="p-2 rounded-full hover:bg-black/5"><Icon name="type" size={20} /></button>
                            <button onClick={() => { setShowTOC(!showTOC); setShowAppearance(false); }} className="p-2 rounded-full hover:bg-black/5"><Icon name="list" size={20} /></button>
                        </div>
                    </div>

                    <div className="flex-1 relative overflow-hidden">
                        {!ready && <div className="absolute inset-0 flex flex-col items-center justify-center gap-2 z-10"><div className="animate-spin rounded-full h-8 w-8 border-b-2 border-ios-blue"></div><div className="text-xs opacity-50">Indexing Book...</div></div>}
                        <div ref={viewerRef} className="w-full h-full"></div>
                        <div className="absolute inset-y-0 left-0 w-20 z-0" onClick={() => nav('prev')}></div>
                        <div className="absolute inset-y-0 right-0 w-20 z-0" onClick={() => nav('next')}></div>
                    </div>

                    <div className={`h-16 border-t px-6 flex flex-col justify-center safe-bottom z-20 ${theme === 'dark' ? 'border-gray-800 bg-[#1c1c1e]' : 'border-gray-200 bg-white'}`}>
                        <input type="range" min="0" max="100" step="1" value={progress} onChange={handleSlider} className="w-full h-1 bg-gray-300 rounded-full mb-1" />
                        <div className="flex justify-between text-[10px] opacity-50 font-mono"><span>{progress}%</span><span>{book?.locations?.total || '...'} locs</span></div>
                    </div>

                    {showTOC && (
                        <div className="absolute inset-0 top-14 bottom-16 bg-black/50 backdrop-blur-sm z-30" onClick={() => setShowTOC(false)}>
                            <div className={`absolute top-0 right-0 bottom-0 w-72 shadow-2xl overflow-y-auto animate-in slide-in-from-right ${theme === 'dark' ? 'bg-[#2c2c2e]' : 'bg-white'}`} onClick={e => e.stopPropagation()}>
                                <div className="p-4 font-bold border-b border-gray-200/10">Contents</div>
                                {toc.map((item, i) => (
                                    <div key={i} onClick={() => { rendition.display(item.href); setShowTOC(false); }} className="p-3 border-b border-gray-200/10 text-sm hover:bg-white/10 cursor-pointer">{item.label}</div>
                                ))}
                            </div>
                        </div>
                    )}

                    {showAppearance && (
                        <div className="absolute inset-0 z-30" onClick={() => setShowAppearance(false)}>
                             <div className={`absolute top-16 right-4 w-72 rounded-xl shadow-2xl p-4 animate-in zoom-in-95 ${theme === 'dark' ? 'bg-[#2c2c2e] border border-gray-700' : 'bg-white border border-gray-200'}`} onClick={e => e.stopPropagation()}>
                                 <div className="flex justify-between bg-gray-200/20 rounded-lg p-1 mb-4">
                                     {['light', 'sepia', 'dark'].map(t => (
                                         <button key={t} onClick={() => setTheme(t)} className={`flex-1 py-2 rounded-md capitalize text-sm font-medium ${theme === t ? 'bg-white shadow-sm text-black' : 'text-gray-500 hover:text-gray-900'}`} style={theme === t && t === 'dark' ? {background: '#555', color: 'white'} : {}}>{t}</button>
                                     ))}
                                 </div>
                                 <div className="flex justify-between gap-2 mb-4">
                                     <button onClick={() => setFontFamily('sans-serif')} className={`flex-1 py-2 border rounded-lg text-sm ${fontFamily === 'sans-serif' ? 'border-ios-blue text-ios-blue bg-blue-50/10' : 'border-gray-200/20'}`}>Sans</button>
                                     <button onClick={() => setFontFamily('serif')} className={`flex-1 py-2 border rounded-lg text-sm font-serif ${fontFamily === 'serif' ? 'border-ios-blue text-ios-blue bg-blue-50/10' : 'border-gray-200/20'}`}>Serif</button>
                                 </div>
                                 <div className="flex items-center justify-between gap-4 mb-4">
                                     <button onClick={() => setFontSize(Math.max(50, fontSize - 10))} className="p-2 border rounded-lg border-gray-200/20"><Icon name="minus" size={16} /></button>
                                     <span className="text-sm font-mono w-12 text-center">{fontSize}%</span>
                                     <button onClick={() => setFontSize(Math.min(200, fontSize + 10))} className="p-2 border rounded-lg border-gray-200/20"><Icon name="plus" size={16} /></button>
                                 </div>
                                 <div className="border-t border-gray-200/10 pt-3">
                                     <div className="text-xs uppercase font-bold opacity-50 mb-2">Dialogue Color</div>
                                     <div className="flex gap-2">
                                         {['none', 'blue', 'red', 'purple'].map(c => (
                                             <button key={c} onClick={() => setHighlightColor(c)} className={`flex-1 h-8 rounded border flex items-center justify-center ${highlightColor === c ? 'border-black/50 shadow-inner' : 'border-transparent'}`} style={{background: c === 'none' ? 'transparent' : getHighlightColorCode(c, 'light'), border: c === 'none' ? '1px solid #ccc' : ''}}>
                                                {c === 'none' && <Icon name="slash" size={12} className="opacity-50" />}
                                                {highlightColor === c && c !== 'none' && <div className="w-2 h-2 bg-white rounded-full"></div>}
                                             </button>
                                         ))}
                                     </div>
                                 </div>
                             </div>
                        </div>
                    )}
                </div>
            );
        };

        // 3. BOOK EDITOR (Unchanged)
        const BookEditor = ({ bookId, onClose, onSave }) => {
            const [title, setTitle] = useState("Untitled Book");
            const [author, setAuthor] = useState("Unknown Author");
            const [coverId, setCoverId] = useState(null);
            const [coverPreview, setCoverPreview] = useState(null);
            const [epubId, setEpubId] = useState(null);
            const [tracks, setTracks] = useState([]);
            const [processing, setProcessing] = useState(false);
            const [status, setStatus] = useState("");
            const [splitTarget, setSplitTarget] = useState(null);

            useEffect(() => {
                if (!bookId) return;
                const load = async () => {
                    const book = await dbOp('readonly', 'books', s => s.get(bookId));
                    if (book) {
                        setTitle(book.title);
                        setAuthor(book.author);
                        setCoverId(book.coverId);
                        setEpubId(book.epubId);
                        const normalizedTracks = (book.tracks || []).map(t => ({
                            ...t,
                            fileId: t.fileId || t.id,
                            start: t.start || 0,
                            duration: t.duration || null 
                        }));
                        setTracks(normalizedTracks);
                        if (book.coverId) {
                            const f = await dbOp('readonly', 'files', s => s.get(book.coverId));
                            if (f) setCoverPreview(URL.createObjectURL(f.data));
                        }
                    }
                };
                load();
            }, [bookId]);

            const handleCoverUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                setCoverPreview(URL.createObjectURL(file));
                const id = crypto.randomUUID();
                setCoverId(id);
                await saveFiles([{ id, data: file, type: 'image' }]);
            };

            const handleEpubUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const id = crypto.randomUUID();
                setEpubId(id);
                await saveFiles([{ id, data: file, type: 'epub' }]);
            };

            const handleAddTracks = async (e) => {
                setProcessing(true);
                setStatus("Importing tracks...");
                const files = Array.from(e.target.files);
                const newFiles = [];
                const newTracks = [];
                for (let f of files) {
                    if (f.name.endsWith('.mp3') || f.name.endsWith('.wav') || f.name.endsWith('.m4a') || f.type.startsWith('audio/')) {
                        const id = crypto.randomUUID();
                        newFiles.push({ id, data: f, type: 'audio' });
                        newTracks.push({ id, fileId: id, name: f.name, start: 0, duration: null });
                    }
                }
                await saveFiles(newFiles);
                setTracks(prev => [...prev, ...newTracks]);
                setProcessing(false);
            };

            const openSplitMenu = async (idx) => {
                const track = tracks[idx];
                const fileRec = await dbOp('readonly', 'files', s => s.get(track.fileId));
                if (!fileRec) return;
                setSplitTarget({ idx, track, file: fileRec.data });
            };

            const executeSplitByTime = async (minutes) => {
                const { idx, track, file } = splitTarget;
                setSplitTarget(null);
                setProcessing(true);
                setStatus("Calculating Duration...");
                try {
                    const audio = document.createElement('audio');
                    audio.muted = true;
                    const url = URL.createObjectURL(file);
                    audio.src = url;
                    await new Promise(r => audio.onloadedmetadata = r);
                    const duration = audio.duration;
                    URL.revokeObjectURL(url);

                    const chunkSeconds = minutes * 60;
                    const parts = Math.ceil(duration / chunkSeconds);
                    const newTracks = [];
                    for (let i = 0; i < parts; i++) {
                        const start = i * chunkSeconds;
                        const end = Math.min((i + 1) * chunkSeconds, duration);
                        newTracks.push({
                            id: crypto.randomUUID(),
                            fileId: track.fileId,
                            name: `${track.name} - Part ${i + 1}`,
                            start: start,
                            duration: end - start
                        });
                    }
                    const updated = [...tracks];
                    updated.splice(idx, 1, ...newTracks);
                    setTracks(updated);
                    setStatus(`Split into ${parts} parts!`);
                } catch(e) { alert("Error splitting file."); } finally { setProcessing(false); setTimeout(() => setStatus(""), 2000); }
            };

            const executeSplitSilence = async () => {
                alert("Please use Time Split for large files.");
                setSplitTarget(null);
            };

            const sortTracks = () => {
                const sorted = [...tracks].sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
                setTracks(sorted);
            };

            const removeTrack = (idx) => { setTracks(prev => prev.filter((_, i) => i !== idx)); };

            const handleSave = async () => {
                const id = bookId || crypto.randomUUID();
                let currentTrackIndex = 0;
                let currentTime = 0;
                if (bookId) {
                    const old = await dbOp('readonly', 'books', s => s.get(bookId));
                    if (old) { currentTrackIndex = old.currentTrackIndex; currentTime = old.currentTime; }
                }
                const book = { id, title, author, coverId, epubId, tracks, updatedAt: Date.now(), currentTrackIndex, currentTime };
                await dbOp('readwrite', 'books', s => s.put(book));
                onSave();
            };

            return (
                <div className="fixed inset-0 z-50 bg-ios-bg flex flex-col animate-in slide-in-from-bottom duration-300">
                    <div className="bg-white/90 backdrop-blur border-b border-ios-border px-4 py-3 flex justify-between items-center safe-top">
                        <button onClick={onClose} className="text-ios-blue font-medium">Cancel</button>
                        <span className="font-semibold">Edit Book</span>
                        <button onClick={handleSave} className="text-ios-blue font-bold">Save</button>
                    </div>

                    <div className="flex-1 overflow-y-auto p-4 pb-20 safe-bottom">
                        <div className="flex gap-4 mb-6">
                            <div className="w-28 h-28 bg-gray-200 rounded-lg flex-shrink-0 relative overflow-hidden group shadow-sm">
                                {coverPreview ? <img src={coverPreview} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center text-gray-400"><Icon name="image" /></div>}
                                <label className="absolute inset-0 bg-black/20 flex items-center justify-center opacity-0 group-hover:opacity-100 transition cursor-pointer">
                                    <span className="text-white text-xs font-bold bg-black/50 px-2 py-1 rounded">Edit</span>
                                    <input type="file" accept="image/*" className="hidden" onChange={handleCoverUpload} />
                                </label>
                            </div>
                            <div className="flex-1 space-y-3">
                                <input type="text" placeholder="Title" value={title} onChange={e => setTitle(e.target.value)} className="w-full bg-white p-2 rounded-lg border border-gray-200 text-lg font-semibold" />
                                <input type="text" placeholder="Author" value={author} onChange={e => setAuthor(e.target.value)} className="w-full bg-white p-2 rounded-lg border border-gray-200 text-gray-600" />
                            </div>
                        </div>

                        <div className="bg-white rounded-xl shadow-sm p-4 mb-6 flex items-center justify-between">
                            <div className="flex items-center gap-3">
                                <div className={`p-2 rounded-lg ${epubId ? 'bg-green-100 text-green-600' : 'bg-gray-100 text-gray-400'}`}><Icon name="book" size={20} /></div>
                                <div><h4 className="font-medium">E-Book File</h4><p className="text-xs text-gray-500">{epubId ? "EPUB Loaded" : "No EPUB uploaded"}</p></div>
                            </div>
                            <label className="text-sm font-medium text-ios-blue cursor-pointer bg-blue-50 px-3 py-1.5 rounded-full">{epubId ? "Change" : "Upload"}
                                <input type="file" accept=".epub,application/epub+zip" className="hidden" onChange={handleEpubUpload} />
                            </label>
                        </div>

                        <div className="mb-2 flex items-center justify-between px-1">
                            <h3 className="font-bold text-gray-500 uppercase tracking-wide text-xs">Audio Tracks ({tracks.length})</h3>
                            <button onClick={sortTracks} className="text-ios-blue text-xs font-medium">Sort by Name</button>
                        </div>

                        <div className="bg-white rounded-xl shadow-sm overflow-hidden">
                            {tracks.length === 0 ? <div className="p-6 text-center text-gray-400 text-sm">No tracks yet.</div> : (
                                <div className="divide-y divide-gray-100">
                                    {tracks.map((t, idx) => (
                                        <div key={idx} className="p-3 flex items-center gap-3">
                                            <span className="text-gray-400 text-xs font-mono w-5">{idx + 1}</span>
                                            <div className="flex-1 min-w-0"><div className="truncate text-sm text-gray-800 font-medium">{t.name}</div><div className="text-xs text-gray-400">{t.start > 0 ? `Start: ${formatTime(t.start)}` : 'Full File'}{t.duration && ` • ${formatTime(t.duration)}`}</div></div>
                                            {(!t.duration || t.duration > 120) && <button onClick={() => openSplitMenu(idx)} className="text-gray-400 bg-gray-50 p-2 rounded-full hover:bg-ios-blue hover:text-white transition"><Icon name="scissors" size={16} /></button>}
                                            <button onClick={() => removeTrack(idx)} className="text-red-400 p-2 rounded-full hover:bg-red-50"><Icon name="minus-circle" size={16} /></button>
                                        </div>
                                    ))}
                                </div>
                            )}
                            <div className="p-3 bg-gray-50 border-t border-gray-100">
                                {processing ? <div className="flex flex-col items-center justify-center py-2 gap-2"><div className="animate-spin rounded-full h-5 w-5 border-b-2 border-ios-blue"></div><div className="text-xs text-gray-500">{status}</div></div> : (
                                    <label className="flex items-center justify-center gap-2 text-ios-blue font-semibold cursor-pointer w-full py-2"><Icon name="plus-circle" size={20} /> Add Audio Files
                                        <input type="file" multiple accept=".mp3,.wav,.m4a,audio/*" className="hidden" onChange={handleAddTracks} />
                                    </label>
                                )}
                            </div>
                        </div>
                    </div>
                    {splitTarget && <SplitOptions file={splitTarget.file} onSplitByTime={executeSplitByTime} onSplitSilence={executeSplitSilence} onCancel={() => setSplitTarget(null)} />}
                </div>
            );
        };

        // 4. PLAYER (Gapless Logic)
        const Player = ({ bookId, onBack }) => {
            const audioRef = useRef(null);
            const [book, setBook] = useState(null);
            const [cover, setCover] = useState(null);
            const [playing, setPlaying] = useState(false);
            const [time, setTime] = useState(0);
            const [dur, setDur] = useState(0); 
            const [showList, setShowList] = useState(false);
            const [showReader, setShowReader] = useState(false);
            const activeFileId = useRef(null);

            useEffect(() => {
                const load = async () => {
                    const b = await dbOp('readonly', 'books', s => s.get(bookId));
                    setBook(b);
                    if (b.coverId) {
                        const f = await dbOp('readonly', 'files', s => s.get(b.coverId));
                        if(f) setCover(URL.createObjectURL(f.data));
                    }
                    if (b.tracks.length > 0) await loadTrack(b, b.currentTrackIndex || 0, false);
                };
                load();
            }, [bookId]);

            const loadTrack = async (b, index, autoPlay) => {
                const track = b.tracks[index];
                if (!track) return;
                const fileId = track.fileId || track.id;
                const startTime = track.start || 0;
                
                if (activeFileId.current !== fileId) {
                    const f = await dbOp('readonly', 'files', s => s.get(fileId));
                    if (f) {
                        const url = URL.createObjectURL(f.data);
                        audioRef.current.src = url;
                        activeFileId.current = fileId;
                        audioRef.current.currentTime = (index === b.currentTrackIndex) ? (b.currentTime || startTime) : startTime;
                    }
                } else {
                    const buffer = 1; 
                    if (audioRef.current.currentTime < startTime - buffer || audioRef.current.currentTime > (track.start + (track.duration||99999))) {
                        audioRef.current.currentTime = startTime;
                    }
                }
                if (autoPlay) { try { await audioRef.current.play(); setPlaying(true); } catch(e){} }
            };

            const updateBookProgress = (t) => {
                if (!bookId) return;
                // Atomic Patch
                patchBook(bookId, { currentTime: t });
            };

            const changeTrack = async (idx) => {
                const b = { ...book, currentTrackIndex: idx };
                const t = b.tracks[idx];
                b.currentTime = t.start || 0; 
                setBook(b);
                await loadTrack(b, idx, true);
                patchBook(bookId, { currentTrackIndex: idx, currentTime: b.currentTime });
            };

            const handleTimeUpdate = () => {
                const ct = audioRef.current.currentTime;
                setTime(ct);
                setDur(audioRef.current.duration);
                updateBookProgress(ct);

                if (book && book.tracks[book.currentTrackIndex]) {
                    const current = book.tracks[book.currentTrackIndex];
                    const endTime = (current.start || 0) + (current.duration || 999999);
                    
                    if (current.duration && ct >= endTime - 0.2) {
                        if (book.currentTrackIndex < book.tracks.length - 1) {
                            const nextIndex = book.currentTrackIndex + 1;
                            const nextTrack = book.tracks[nextIndex];
                            setBook(prev => ({ ...prev, currentTrackIndex: nextIndex }));
                            
                            if ((nextTrack.fileId || nextTrack.id) === (current.fileId || current.id)) {
                                patchBook(bookId, { currentTrackIndex: nextIndex });
                            } else {
                                changeTrack(nextIndex);
                            }
                        } else {
                            setPlaying(false);
                        }
                    }
                }
            };

            if (!book) return null;

            const currentTrack = book.tracks[book.currentTrackIndex];
            const trackStart = currentTrack?.start || 0;
            const trackDur = currentTrack?.duration || dur;
            const sliderVal = time - trackStart;
            
            return (
                <div className="h-full flex flex-col bg-ios-bg">
                    <div className="safe-top px-4 pt-4 flex justify-between items-center z-10">
                        <button onClick={onBack} className="p-2 text-gray-500"><Icon name="chevron-down" /></button>
                        <span className="text-xs font-bold text-gray-400 uppercase tracking-widest">Now Playing</span>
                        <button onClick={() => setShowList(true)} className="p-2 text-gray-500"><Icon name="list" /></button>
                    </div>

                    <div className="flex-1 flex flex-col items-center justify-center p-8 space-y-8">
                        <div className={`w-full max-w-xs aspect-square rounded-2xl shadow-ios-float overflow-hidden bg-gray-200 transform transition-transform duration-500 ${playing ? 'scale-105' : 'scale-100'}`}>
                            {cover ? <img src={cover} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center text-gray-400"><Icon name="music" size={64} /></div>}
                        </div>

                        <div className="text-center w-full max-w-sm">
                            <h2 className="text-2xl font-bold truncate px-4">{book.title}</h2>
                            <p className="text-gray-500">{book.author}</p>
                            <div className="bg-blue-100 text-ios-blue text-xs font-bold px-3 py-1 rounded-full inline-block mt-2 truncate max-w-full">
                                {currentTrack?.name || "No Track"}
                            </div>
                        </div>

                        <div className="w-full max-w-sm px-4">
                            <input 
                                type="range" 
                                min="0" max={trackDur || 1} 
                                value={Math.max(0, sliderVal)} 
                                onChange={(e) => { 
                                    const seekTime = Number(e.target.value) + trackStart;
                                    audioRef.current.currentTime = seekTime; 
                                    setTime(seekTime); 
                                }}
                                className="w-full h-1 bg-gray-300 rounded-full"
                            />
                            <div className="flex justify-between text-xs text-gray-400 mt-2 font-mono">
                                <span>{formatTime(sliderVal)}</span>
                                <span>-{formatTime(trackDur - sliderVal)}</span>
                            </div>
                        </div>

                        <div className="flex items-center justify-between w-full max-w-xs px-6">
                            <button onClick={() => audioRef.current.currentTime -= 30} className="text-gray-800 flex flex-col items-center gap-1">
                                <Icon name="rotate-ccw" size={32} /> <span className="text-[10px] font-bold">30</span>
                            </button>
                            <button onClick={() => { if(playing) audioRef.current.pause(); else audioRef.current.play(); setPlaying(!playing); }} className="w-20 h-20 bg-slate-900 text-white rounded-full flex items-center justify-center shadow-lg active:scale-95 transition">
                                <Icon name={playing ? "pause" : "play"} size={36} className="ml-1 fill-current" />
                            </button>
                            <button onClick={() => audioRef.current.currentTime += 300} className="text-gray-800 flex flex-col items-center gap-1">
                                <Icon name="rotate-cw" size={32} /> <span className="text-[10px] font-bold">5m</span>
                            </button>
                        </div>
                    </div>

                    {book.epubId && (
                        <div className="safe-bottom pb-8 flex justify-center">
                             <button onClick={() => setShowReader(true)} className="flex items-center gap-2 bg-white px-5 py-3 rounded-full shadow-md text-sm font-bold text-gray-800">
                                <Icon name="book-open" size={18} /> Read Along
                            </button>
                        </div>
                    )}

                    {showList && (
                        <div className="absolute inset-0 z-20 bg-black/40 backdrop-blur-sm flex flex-col justify-end" onClick={() => setShowList(false)}>
                            <div className="bg-white rounded-t-3xl h-2/3 flex flex-col p-4 animate-in slide-in-from-bottom" onClick={e => e.stopPropagation()}>
                                <h3 className="text-lg font-bold mb-4 p-2">Chapters</h3>
                                <div className="overflow-y-auto flex-1">
                                    {book.tracks.map((t, i) => (
                                        <div key={i} onClick={() => { changeTrack(i); setShowList(false); }} className={`p-3 rounded-xl mb-1 flex items-center gap-3 ${i === book.currentTrackIndex ? 'bg-gray-100 text-ios-blue font-semibold' : 'text-gray-600'}`}>
                                            <span className="text-xs text-gray-400 w-6">{i + 1}</span>
                                            <span className="truncate">{t.name}</span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {showReader && <EpubReader bookId={bookId} onClose={() => setShowReader(false)} />}
                    
                    <audio 
                        ref={audioRef} 
                        onTimeUpdate={handleTimeUpdate} 
                        onEnded={() => { if(book.currentTrackIndex >= book.tracks.length - 1) setPlaying(false); }}
                        onError={(e) => console.log("Audio Error", e)}
                    />
                </div>
            );
        };

        // 5. MAIN APP
        const App = () => {
            const [view, setView] = useState('library'); 
            const [activeBookId, setActiveBookId] = useState(null);
            const [editingBookId, setEditingBookId] = useState(null);
            const [isEditing, setIsEditing] = useState(false);
            const [books, setBooks] = useState([]);
            const [covers, setCovers] = useState({});

            const loadLibrary = async () => {
                const list = await dbOp('readonly', 'books', s => s.getAll());
                setBooks(list);
                list.forEach(async b => {
                    if (b.coverId && !covers[b.id]) {
                        const f = await dbOp('readonly', 'files', s => s.get(b.coverId));
                        if(f) setCovers(prev => ({...prev, [b.id]: URL.createObjectURL(f.data)}));
                    }
                });
            };

            useEffect(() => { loadLibrary(); }, []);

            return (
                <>
                    {view === 'library' && (
                        <div className="h-full bg-ios-bg p-6 safe-top overflow-y-auto">
                            <header className="flex justify-between items-center mb-6">
                                <h1 className="text-3xl font-bold tracking-tight">Library</h1>
                                <button onClick={() => { setEditingBookId(null); setIsEditing(true); }} className="bg-ios-blue text-white rounded-full p-2 shadow-lg active:scale-95 transition">
                                    <Icon name="plus" />
                                </button>
                            </header>

                            <div className="grid grid-cols-2 gap-4 pb-20">
                                {books.map(b => (
                                    <div key={b.id} onClick={() => { setActiveBookId(b.id); setView('player'); }} className="relative group">
                                        <div className="aspect-square bg-white rounded-xl shadow-ios overflow-hidden mb-2 relative">
                                            {covers[b.id] ? <img src={covers[b.id]} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center bg-gray-100 text-gray-300"><Icon name="music" size={40} /></div>}
                                            <button 
                                                onClick={(e) => { e.stopPropagation(); setEditingBookId(b.id); setIsEditing(true); }}
                                                className="absolute top-2 right-2 bg-white/90 p-1.5 rounded-full shadow-sm opacity-0 group-hover:opacity-100 transition text-gray-700 hover:text-blue-600"
                                            >
                                                <Icon name="pencil" size={16} />
                                            </button>
                                        </div>
                                        <h3 className="font-semibold text-sm truncate leading-tight">{b.title}</h3>
                                        <p className="text-xs text-gray-500 truncate">{b.author}</p>
                                    </div>
                                ))}
                                {books.length === 0 && <div className="col-span-2 text-center text-gray-400 mt-20">Tap + to create a book</div>}
                            </div>
                        </div>
                    )}

                    {view === 'player' && <Player bookId={activeBookId} onBack={() => setView('library')} />}
                    
                    {isEditing && (
                        <BookEditor 
                            bookId={editingBookId} 
                            onClose={() => setIsEditing(false)} 
                            onSave={() => { setIsEditing(false); loadLibrary(); }} 
                        />
                    )}
                </>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
