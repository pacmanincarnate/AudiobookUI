<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#F2F2F7">
    <title>Audiobook Manager</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- EPUB.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { sans: ['-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'sans-serif'] },
                    colors: {
                        ios: { bg: '#F2F2F7', card: '#FFFFFF', blue: '#007AFF', red: '#FF3B30', gray: '#8E8E93', border: '#C6C6C8' }
                    },
                    boxShadow: { 'ios': '0 2px 12px rgba(0,0,0,0.06)', 'ios-float': '0 8px 30px rgba(0,0,0,0.12)' },
                    keyframes: {
                        shimmer: { '0%': { backgroundPosition: '-1000px 0' }, '100%': { backgroundPosition: '1000px 0' } }
                    },
                    animation: { shimmer: 'shimmer 2s infinite linear' }
                }
            }
        }
    </script>
    <style>
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .safe-top { padding-top: max(env(safe-area-inset-top), 20px); }
        .safe-bottom { padding-bottom: max(env(safe-area-inset-bottom), 20px); }
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 24px; width: 24px; border-radius: 50%;
            background: #fff; box-shadow: 0 2px 6px rgba(0,0,0,0.3); margin-top: -10px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: rgba(0,0,0,0.1); border-radius: 2px;
        }
        select { -webkit-appearance: none; appearance: none; }
    </style>
</head>
<body class="bg-ios-bg text-slate-900 h-screen w-screen overflow-hidden select-none">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // --- GEMINI API CONFIG ---
        const getEffectiveApiKey = () => localStorage.getItem('gemini_api_key') || '';

        // --- AUDIO UTILS (PCM to WAV) ---
        const pcmToWav = (pcmData, sampleRate = 24000) => {
            const buffer = new ArrayBuffer(44 + pcmData.byteLength);
            const view = new DataView(buffer);
            const writeString = (offset, string) => { for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i)); };
            writeString(0, 'RIFF'); view.setUint32(4, 36 + pcmData.byteLength, true); writeString(8, 'WAVE'); writeString(12, 'fmt ');
            view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, 1, true); view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true); view.setUint16(32, 2, true); view.setUint16(34, 16, true); writeString(36, 'data');
            view.setUint32(40, pcmData.byteLength, true);
            const pcmView = new Uint8Array(pcmData);
            const wavView = new Uint8Array(buffer, 44);
            wavView.set(pcmView);
            return buffer;
        };

        const callGeminiTTS = async (text) => {
            const key = getEffectiveApiKey();
            if (!key) throw new Error("API Key missing");
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${key}`;
            const payload = { contents: [{ parts: [{ text }] }], generationConfig: { responseModalities: ["AUDIO"], speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } } } } };
            const response = await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error("TTS API Error");
            const data = await response.json();
            const base64Audio = data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
            if (!base64Audio) throw new Error("No audio data");
            const binaryString = window.atob(base64Audio);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
            const wavBuffer = pcmToWav(bytes.buffer);
            return URL.createObjectURL(new Blob([wavBuffer], { type: 'audio/wav' }));
        };

        const callGeminiSummary = async (text) => {
            const key = getEffectiveApiKey();
            if (!key) throw new Error("API Key missing");
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${key}`;
            const payload = { contents: [{ parts: [{ text: "Summarize this chapter concisely:\n\n" + text.substring(0, 10000) }] }] };
            const response = await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error("Summary API Error");
            const data = await response.json();
            return data.candidates?.[0]?.content?.parts?.[0]?.text || "No summary generated.";
        };

        // --- DB LAYER ---
        const DB_NAME = 'AudiobookManagerDB';
        const DB_VERSION = 2; 
        const openDB = () => new Promise((resolve, reject) => {
            const req = indexedDB.open(DB_NAME, DB_VERSION);
            req.onerror = () => reject('DB Error');
            req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('books')) db.createObjectStore('books', { keyPath: 'id' });
                if (!db.objectStoreNames.contains('files')) db.createObjectStore('files', { keyPath: 'id' });
            };
            req.onsuccess = (e) => resolve(e.target.result);
        });
        const dbOp = async (mode, store, cb) => {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(store, mode);
                const req = cb(tx.objectStore(store));
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        };
        const patchBook = async (bookId, updates) => {
            const db = await openDB();
            const tx = db.transaction('books', 'readwrite');
            const store = tx.objectStore('books');
            const book = await new Promise((resolve, reject) => { const req = store.get(bookId); req.onsuccess = () => resolve(req.result); req.onerror = () => reject(req.error); });
            if (!book) return;
            store.put({ ...book, ...updates });
            return new Promise(resolve => tx.oncomplete = resolve);
        };
        const saveFiles = async (files) => {
            const db = await openDB();
            const tx = db.transaction('files', 'readwrite');
            const store = tx.objectStore('files');
            files.forEach(f => store.put(f));
            return new Promise(resolve => tx.oncomplete = resolve);
        };

        const Icon = ({ name, size = 24, className = "" }) => {
            useEffect(() => lucide.createIcons(), [name]);
            return <i data-lucide={name} width={size} height={size} className={className}></i>;
        };

        const formatTime = (s) => {
            if (!s || isNaN(s)) return "0:00";
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return `${m}:${sec.toString().padStart(2, '0')}`;
        };

        // --- COMPONENTS ---

        const SettingsModal = ({ onClose }) => {
            const [key, setKey] = useState(getEffectiveApiKey());
            return (
                <div className="fixed inset-0 z-[70] flex items-center justify-center bg-black/40 backdrop-blur-sm p-4 animate-in fade-in">
                    <div className="bg-white rounded-2xl w-full max-w-sm p-6 shadow-2xl">
                        <h3 className="text-xl font-bold mb-4">Settings</h3>
                        <label className="block text-sm font-medium text-gray-700 mb-2">Google Gemini API Key</label>
                        <input type="password" value={key} onChange={e => setKey(e.target.value)} placeholder="AIzaSy..." className="w-full p-3 border rounded-xl bg-gray-50 mb-4 font-mono text-sm" />
                        <p className="text-xs text-gray-400 mb-6">Required for AI Narrator and Summarization features.</p>
                        <div className="flex gap-3">
                            <button onClick={onClose} className="flex-1 py-2 text-gray-600 font-medium">Cancel</button>
                            <button onClick={() => { localStorage.setItem('gemini_api_key', key); onClose(); }} className="flex-1 py-2 bg-ios-blue text-white rounded-xl font-semibold">Save</button>
                        </div>
                    </div>
                </div>
            );
        };

        const AIModal = ({ type, content, onClose }) => {
            return (
                <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/40 backdrop-blur-sm p-6 animate-in fade-in">
                    <div className="bg-white rounded-2xl w-full max-w-lg shadow-2xl flex flex-col max-h-[80vh]">
                        <div className="p-4 border-b flex items-center gap-2"><Icon name={type === 'summary' ? 'sparkles' : 'mic'} className="text-ios-blue" /><h3 className="font-bold text-lg">{type === 'summary' ? 'Chapter Summary' : 'AI Narrator'}</h3></div>
                        <div className="p-6 overflow-y-auto">{content ? <p className="leading-relaxed text-gray-800 whitespace-pre-wrap">{content}</p> : <div className="flex flex-col items-center justify-center py-8"><div className="animate-spin rounded-full h-8 w-8 border-b-2 border-ios-blue mb-4"></div><p className="text-gray-500 animate-pulse">Consulting the AI...</p></div>}</div>
                        <div className="p-4 border-t bg-gray-50 rounded-b-2xl"><button onClick={onClose} className="w-full py-3 bg-white border border-gray-200 rounded-xl font-semibold text-gray-700 shadow-sm">Close</button></div>
                    </div>
                </div>
            );
        };

        const EpubReader = ({ bookId, onClose }) => {
            const viewerRef = useRef(null);
            const [book, setBook] = useState(null);
            const [rendition, setRendition] = useState(null);
            const [toc, setToc] = useState([]);
            const [progress, setProgress] = useState(0);
            const [ready, setReady] = useState(false);
            const [showTOC, setShowTOC] = useState(false);
            const [showAppearance, setShowAppearance] = useState(false);
            const [aiModal, setAiModal] = useState(null);
            const [summaryText, setSummaryText] = useState(null);
            const [isReadingAloud, setIsReadingAloud] = useState(false);
            const [scanning, setScanning] = useState(false);
            const [isEditingTOC, setIsEditingTOC] = useState(false);
            const audioPlayerRef = useRef(new Audio());

            const fontOptions = [
                { label: 'System UI', value: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif' },
                { label: 'Helvetica Neue', value: '"Helvetica Neue", Helvetica, Arial, sans-serif' },
                { label: 'Verdana', value: 'Verdana, Geneva, sans-serif' },
                { label: 'Lato', value: 'Lato, sans-serif' },
                { label: 'Charter', value: 'Charter, "Bitstream Charter", serif' },
                { label: 'Georgia', value: 'Georgia, serif' },
                { label: 'Iowan Old Style', value: '"Iowan Old Style", serif' },
                { label: 'Times New Roman', value: '"Times New Roman", Times, serif' },
            ];

            const [settings, setSettings] = useState(() => {
                const saved = localStorage.getItem('reader_settings');
                return saved ? JSON.parse(saved) : {
                    theme: 'light',
                    fontSize: 100,
                    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                    lineHeight: 1.5,
                    dialogueEnhance: false,
                    textColor: '#000000'
                };
            });

            useEffect(() => { localStorage.setItem('reader_settings', JSON.stringify(settings)); }, [settings]);
            const updateSetting = (key, value) => setSettings(prev => ({ ...prev, [key]: value }));

            useEffect(() => {
                const init = async () => {
                    if (!bookId) return;
                    const bookMeta = await dbOp('readonly', 'books', s => s.get(bookId));
                    if (!bookMeta || !bookMeta.epubId) return;
                    const f = await dbOp('readonly', 'files', s => s.get(bookMeta.epubId));
                    if (!f) return;
                    
                    const newBook = ePub(f.data);
                    setBook(newBook);
                    const rend = newBook.renderTo(viewerRef.current, { width: "100%", height: "100%", flow: "paginated" });
                    setRendition(rend);

                    rend.hooks.content.register((contents) => {
                        const doc = contents.document;
                        const style = doc.createElement('style');
                        // Use currentColor to ensure shadow matches text color exactly
                        style.textContent = `.dialogue-text { display: inline; color: inherit; }`; 
                        doc.head.appendChild(style);

                        const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_TEXT, null, false);
                        const nodes = [];
                        while(walker.nextNode()) nodes.push(walker.currentNode);

                        const regex = /([“"”][^"”]*[”"“])|("[^"]*")/g; 

                        nodes.forEach(node => {
                            if (!node.nodeValue || node.parentElement.tagName === 'SCRIPT' || node.parentElement.tagName === 'STYLE') return;
                            const text = node.nodeValue;
                            if (!regex.test(text)) return;
                            
                            regex.lastIndex = 0;
                            const fragment = doc.createDocumentFragment();
                            let lastIndex = 0;
                            let match;

                            while ((match = regex.exec(text)) !== null) {
                                if (match.index > lastIndex) fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                                const span = doc.createElement('span');
                                span.className = 'dialogue-text';
                                span.textContent = match[0];
                                // Use CSS Variable for instant switching
                                span.style.textShadow = 'var(--dialogue-shadow, none)';
                                fragment.appendChild(span);
                                lastIndex = regex.lastIndex;
                            }
                            if (lastIndex < text.length) fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
                            node.parentNode.replaceChild(fragment, node);
                        });
                    });

                    const initialLocation = bookMeta.lastReadLocation || undefined;
                    await rend.display(initialLocation);
                    
                    newBook.ready.then(() => newBook.locations.generate(1000)).then(() => setReady(true));
                    
                    const navigation = await newBook.loaded.navigation;
                    if (bookMeta.customTOC) {
                        setToc(bookMeta.customTOC);
                    } else {
                        setToc(navigation.toc);
                    }

                    rend.themes.register('light', { body: { background: '#fff' } });
                    rend.themes.register('sepia', { body: { background: '#f6f1d1' } });
                    rend.themes.register('dark', { body: { background: '#1c1c1e' } });
                    
                    rend.on('relocated', (location) => {
                        setProgress(Math.floor(location.start.percentage * 100));
                        patchBook(bookId, { lastReadLocation: location.start.cfi });
                    });
                };
                init();
                return () => { if (audioPlayerRef.current) { audioPlayerRef.current.pause(); audioPlayerRef.current.src = ""; } };
            }, [bookId]);

            // Appearance Effect
            useEffect(() => {
                if(rendition) {
                    rendition.themes.select(settings.theme);
                    rendition.themes.fontSize(settings.fontSize + '%');
                    rendition.themes.font(settings.fontFamily);
                    
                    // Shadow logic: gentle glow centered
                    const shadowStyle = settings.dialogueEnhance ? '0 0 2px currentColor' : 'none';
                    
                    rendition.themes.register('custom-styles', { 
                        'body': { 
                            'color': `${settings.textColor} !important`,
                            'line-height': `${settings.lineHeight} !important`,
                            '--dialogue-shadow': shadowStyle
                        }
                    });
                    rendition.themes.select('custom-styles');
                }
            }, [settings, rendition]);

            // ... TOC & AI Functions (Unchanged) ...
            const scanChapters = async () => {
                if (!book) return;
                setScanning(true);
                const newToc = [];
                try {
                    for (let i = 0; i < book.spine.length; i++) {
                        const item = book.spine.get(i);
                        const doc = await item.load(book.load.bind(book));
                        const titleEl = doc.querySelector('h1, h2, h3, .title, .chapter');
                        let label = "";
                        if (titleEl && titleEl.innerText.trim().length > 0 && titleEl.innerText.length < 100) {
                            label = titleEl.innerText.trim();
                        } else {
                            const pTags = doc.querySelectorAll('p');
                            for (let p of pTags) {
                                const text = p.innerText.trim();
                                if (/^(Chapter|Part|Prologue|Epilogue)\s+\d+/i.test(text) || /^\d+$/.test(text)) {
                                    if (text.length < 50) { label = text; break; }
                                }
                            }
                        }
                        if (label) newToc.push({ label: label, href: item.href });
                    }
                    if (newToc.length > 0) {
                        setToc(newToc);
                        await patchBook(bookId, { customTOC: newToc });
                        alert(`Found ${newToc.length} chapters.`);
                    } else {
                        alert("No chapters detected.");
                    }
                } catch (e) { console.error(e); alert("Scan failed."); } finally { setScanning(false); }
            };

            const updateTocItem = (index, newLabel) => {
                const newToc = [...toc];
                newToc[index] = { ...newToc[index], label: newLabel };
                setToc(newToc);
            };

            const saveTOC = async () => {
                await patchBook(bookId, { customTOC: toc });
                setIsEditingTOC(false);
            };

            const getVisibleText = () => {
                if (!rendition) return null;
                const visible = rendition.currentLocation();
                if (!visible || !visible.start || !visible.end) return null;
                try {
                    const range = rendition.getRange(visible.start.cfi, visible.end.cfi);
                    return range.toString();
                } catch(e) {
                    console.log("Range Error", e);
                    return null;
                }
            };

            const getCurrentChapterText = async () => {
                if (!rendition || !book) return null;
                const cfi = rendition.currentLocation().start.cfi;
                const item = book.spine.get(cfi);
                if (!item) return null;
                try {
                    const doc = await item.load(book.load.bind(book));
                    const body = doc.body || doc.querySelector('body') || doc.documentElement;
                    return body ? (body.innerText || body.textContent || "") : "";
                } catch (e) {
                    console.warn("Text extraction error", e);
                    return "";
                }
            };

            const handleSummary = async () => {
                setAiModal('summary'); setSummaryText(null);
                try {
                    const text = await getCurrentChapterText();
                    if (!text || text.length < 50) throw new Error("Could not extract enough text.");
                    const summary = await callGeminiSummary(text);
                    setSummaryText(summary);
                } catch (e) { setSummaryText("Error: " + e.message); }
            };

            const handleTTS = async () => {
                if (isReadingAloud) { audioPlayerRef.current.pause(); setIsReadingAloud(false); return; }
                try {
                    let textToRead = getVisibleText();
                    if (!textToRead || textToRead.trim().length < 5) {
                        const fullText = await getCurrentChapterText();
                        textToRead = fullText ? fullText.substring(0, 2500) : ""; 
                    }
                    if (!textToRead || textToRead.length < 5) { alert("Not enough text found."); return; }
                    setIsReadingAloud(true);
                    const audioUrl = await callGeminiTTS(textToRead);
                    audioPlayerRef.current.src = audioUrl; audioPlayerRef.current.play(); audioPlayerRef.current.onended = () => setIsReadingAloud(false);
                } catch (e) { alert("TTS Error: " + e.message); setIsReadingAloud(false); }
            };

            const handleSlider = (e) => {
                const val = e.target.value; setProgress(val);
                if (book && book.locations.length() > 0) { const cfi = book.locations.cfiFromPercentage(val / 100); rendition.display(cfi); }
            };
            const nav = (dir) => { if(rendition) dir === 'next' ? rendition.next() : rendition.prev(); };

            return (
                <div className={`fixed inset-0 z-50 flex flex-col ${settings.theme === 'dark' ? 'bg-[#1c1c1e] text-gray-200' : (settings.theme === 'sepia' ? 'bg-[#f6f1d1] text-[#5f4b32]' : 'bg-white text-gray-900')}`}>
                    <div className={`h-14 border-b flex items-center justify-between px-4 safe-top z-20 ${settings.theme === 'dark' ? 'border-gray-800' : 'border-gray-200 bg-white/50 backdrop-blur'}`}>
                        <button onClick={onClose} className="text-ios-blue font-semibold">Done</button>
                        <div className="flex gap-2">
                             <button onClick={handleTTS} className={`p-2 rounded-full ${isReadingAloud ? 'bg-ios-blue text-white animate-pulse' : 'hover:bg-black/5'}`} title="AI Narrator"><Icon name="headphones" size={20} /></button>
                             <button onClick={handleSummary} className="p-2 rounded-full hover:bg-black/5" title="Summarize"><Icon name="sparkles" size={20} /></button>
                            <div className="w-px h-6 bg-gray-300 mx-1"></div>
                            <button onClick={() => { setShowAppearance(!showAppearance); setShowTOC(false); }} className="p-2 rounded-full hover:bg-black/5"><Icon name="type" size={20} /></button>
                            <button onClick={() => { setShowTOC(!showTOC); setShowAppearance(false); }} className="p-2 rounded-full hover:bg-black/5"><Icon name="list" size={20} /></button>
                        </div>
                    </div>

                    <div className="flex-1 relative overflow-hidden">
                        {!ready && <div className="absolute inset-0 flex flex-col items-center justify-center gap-2 z-10"><div className="animate-spin rounded-full h-8 w-8 border-b-2 border-ios-blue"></div><div className="text-xs opacity-50">Indexing Book...</div></div>}
                        <div ref={viewerRef} className="w-full h-full"></div>
                        <div className="absolute inset-y-0 left-0 w-20 z-0" onClick={() => nav('prev')}></div>
                        <div className="absolute inset-y-0 right-0 w-20 z-0" onClick={() => nav('next')}></div>
                    </div>

                    <div className={`h-16 border-t px-6 flex flex-col justify-center safe-bottom z-20 ${settings.theme === 'dark' ? 'border-gray-800 bg-[#1c1c1e]' : 'border-gray-200 bg-white'}`}>
                        <input type="range" min="0" max="100" step="1" value={progress} onChange={handleSlider} className="w-full h-1 bg-gray-300 rounded-full mb-1" />
                        <div className="flex justify-between text-[10px] opacity-50 font-mono"><span>{progress}%</span><span>{book?.locations?.total || '...'} locs</span></div>
                    </div>

                    {showTOC && (
                        <div className="absolute inset-0 top-14 bottom-16 bg-black/50 backdrop-blur-sm z-30" onClick={() => setShowTOC(false)}>
                            <div className={`absolute top-0 right-0 bottom-0 w-72 shadow-2xl overflow-y-auto animate-in slide-in-from-right flex flex-col ${settings.theme === 'dark' ? 'bg-[#2c2c2e]' : 'bg-white'}`} onClick={e => e.stopPropagation()}>
                                <div className="p-4 font-bold border-b border-gray-200/10 flex justify-between items-center">
                                    <span>Contents</span>
                                    <div className="flex gap-2">
                                        <button onClick={() => isEditingTOC ? saveTOC() : setIsEditingTOC(true)} className={`text-xs px-2 py-1 rounded ${isEditingTOC ? 'bg-ios-blue text-white' : 'bg-gray-200 text-gray-800'}`}>{isEditingTOC ? "Done" : "Edit"}</button>
                                        {!isEditingTOC && <button onClick={scanChapters} className="text-xs bg-gray-200 text-gray-800 px-2 py-1 rounded" disabled={scanning}>{scanning ? "Scanning..." : "Auto-Detect"}</button>}
                                    </div>
                                </div>
                                <div className="flex-1 overflow-y-auto">
                                    {toc.map((item, i) => (
                                        <div key={i} className="p-3 border-b border-gray-200/10 text-sm hover:bg-white/10 flex items-center">
                                            {isEditingTOC ? (
                                                <input type="text" value={item.label} onChange={(e) => updateTocItem(i, e.target.value)} className="w-full bg-transparent border-b border-gray-300 focus:outline-none focus:border-ios-blue py-1" />
                                            ) : (
                                                <div onClick={() => { rendition.display(item.href); setShowTOC(false); }} className="cursor-pointer w-full">{item.label}</div>
                                            )}
                                        </div>
                                    ))}
                                    {toc.length === 0 && !scanning && <div className="p-8 text-center text-gray-400 text-sm">No chapters found.<br/>Try Auto-Detect.</div>}
                                </div>
                            </div>
                        </div>
                    )}

                    {showAppearance && (
                        <div className="absolute inset-0 z-30" onClick={() => setShowAppearance(false)}>
                             <div className={`absolute top-16 right-4 w-72 rounded-xl shadow-2xl p-4 animate-in zoom-in-95 overflow-y-auto max-h-[80vh] ${settings.theme === 'dark' ? 'bg-[#2c2c2e] border border-gray-700' : 'bg-white border border-gray-200'}`} onClick={e => e.stopPropagation()}>
                                 <div className="flex justify-between bg-gray-200/20 rounded-lg p-1 mb-4">
                                     {['light', 'sepia', 'dark'].map(t => (
                                         <button key={t} onClick={() => updateSetting('theme', t)} className={`flex-1 py-2 rounded-md capitalize text-sm font-medium ${settings.theme === t ? 'bg-white shadow-sm text-black' : 'text-gray-500 hover:text-gray-900'}`} style={settings.theme === t && t === 'dark' ? {background: '#555', color: 'white'} : {}}>{t}</button>
                                     ))}
                                 </div>
                                 
                                 {/* Font Dropdown */}
                                 <div className="mb-4">
                                     <div className="text-xs uppercase font-bold opacity-50 mb-1">Font</div>
                                     <select 
                                        value={settings.fontFamily} 
                                        onChange={(e) => updateSetting('fontFamily', e.target.value)}
                                        className="w-full p-2 rounded-lg bg-gray-200/20 border-none text-sm"
                                     >
                                        {fontOptions.map(f => <option key={f.value} value={f.value}>{f.label}</option>)}
                                     </select>
                                 </div>

                                 {/* Line Height */}
                                 <div className="mb-4">
                                     <div className="text-xs uppercase font-bold opacity-50 mb-2">Line Spacing</div>
                                     <div className="flex bg-gray-200/20 rounded-lg p-1">
                                         {[1.2, 1.5, 1.8].map((lh, i) => (
                                             <button key={lh} onClick={() => updateSetting('lineHeight', lh)} className={`flex-1 py-1.5 rounded text-xs font-medium ${settings.lineHeight === lh ? 'bg-white shadow-sm' : ''}`}>
                                                 {i === 0 ? 'Tight' : i === 1 ? 'Normal' : 'Wide'}
                                             </button>
                                         ))}
                                     </div>
                                 </div>

                                 <div className="flex items-center justify-between gap-4 mb-4">
                                     <button onClick={() => updateSetting('fontSize', Math.max(50, settings.fontSize - 10))} className="p-2 border rounded-lg border-gray-200/20"><Icon name="minus" size={16} /></button>
                                     <span className="text-sm font-mono w-12 text-center">{settings.fontSize}%</span>
                                     <button onClick={() => updateSetting('fontSize', Math.min(200, settings.fontSize + 10))} className="p-2 border rounded-lg border-gray-200/20"><Icon name="plus" size={16} /></button>
                                 </div>
                                 <div className="mb-4">
                                     <div className="text-xs uppercase font-bold opacity-50 mb-2">Text Color</div>
                                     <input type="color" value={settings.textColor} onChange={(e) => updateSetting('textColor', e.target.value)} className="w-full h-8 rounded cursor-pointer" />
                                 </div>
                                 
                                 <div className="border-t border-gray-200/10 pt-3 flex items-center justify-between">
                                     <span className="text-sm font-medium">Enhance Dialogue</span>
                                     <button 
                                        onClick={() => updateSetting('dialogueEnhance', !settings.dialogueEnhance)}
                                        className={`w-12 h-6 rounded-full transition-colors relative ${settings.dialogueEnhance ? 'bg-ios-blue' : 'bg-gray-300'}`}
                                     >
                                         <div className={`w-5 h-5 bg-white rounded-full absolute top-0.5 transition-transform ${settings.dialogueEnhance ? 'left-[26px]' : 'left-0.5'}`}></div>
                                     </button>
                                 </div>
                             </div>
                        </div>
                    )}
                    
                    {aiModal === 'summary' && <AIModal type="summary" content={summaryText} onClose={() => setAiModal(null)} />}
                </div>
            );
        };

        const BookEditor = ({ bookId, onClose, onSave }) => {
            const [title, setTitle] = useState("Untitled Book");
            const [author, setAuthor] = useState("Unknown Author");
            const [coverId, setCoverId] = useState(null);
            const [coverPreview, setCoverPreview] = useState(null);
            const [epubId, setEpubId] = useState(null);
            const [tracks, setTracks] = useState([]);
            const [processing, setProcessing] = useState(false);
            const [status, setStatus] = useState("");
            const [splitTarget, setSplitTarget] = useState(null);

            useEffect(() => {
                if (!bookId) return;
                const load = async () => {
                    const book = await dbOp('readonly', 'books', s => s.get(bookId));
                    if (book) {
                        setTitle(book.title);
                        setAuthor(book.author);
                        setCoverId(book.coverId);
                        setEpubId(book.epubId);
                        const normalizedTracks = (book.tracks || []).map(t => ({
                            ...t,
                            fileId: t.fileId || t.id,
                            start: t.start || 0,
                            duration: t.duration || null 
                        }));
                        setTracks(normalizedTracks);
                        if (book.coverId) {
                            const f = await dbOp('readonly', 'files', s => s.get(book.coverId));
                            if (f) setCoverPreview(URL.createObjectURL(f.data));
                        }
                    }
                };
                load();
            }, [bookId]);

            const handleCoverUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                setCoverPreview(URL.createObjectURL(file));
                const id = crypto.randomUUID();
                setCoverId(id);
                await saveFiles([{ id, data: file, type: 'image' }]);
            };

            const handleEpubUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const id = crypto.randomUUID();
                setEpubId(id);
                await saveFiles([{ id, data: file, type: 'epub' }]);
            };

            const handleAddTracks = async (e) => {
                setProcessing(true);
                setStatus("Importing tracks...");
                const files = Array.from(e.target.files);
                const newFiles = [];
                const newTracks = [];
                for (let f of files) {
                    if (f.name.endsWith('.mp3') || f.name.endsWith('.wav') || f.name.endsWith('.m4a') || f.type.startsWith('audio/')) {
                        const id = crypto.randomUUID();
                        newFiles.push({ id, data: f, type: 'audio' });
                        newTracks.push({ id, fileId: id, name: f.name, start: 0, duration: null });
                    }
                }
                await saveFiles(newFiles);
                setTracks(prev => [...prev, ...newTracks]);
                setProcessing(false);
            };

            const openSplitMenu = async (idx) => {
                const track = tracks[idx];
                const fileRec = await dbOp('readonly', 'files', s => s.get(track.fileId));
                if (!fileRec) return;
                setSplitTarget({ idx, track, file: fileRec.data });
            };

            const executeSplitByTime = async (minutes) => {
                const { idx, track, file } = splitTarget;
                setSplitTarget(null);
                setProcessing(true);
                setStatus("Calculating Duration...");
                try {
                    const audio = document.createElement('audio');
                    audio.muted = true;
                    const url = URL.createObjectURL(file);
                    audio.src = url;
                    await new Promise(r => audio.onloadedmetadata = r);
                    const duration = audio.duration;
                    URL.revokeObjectURL(url);

                    const chunkSeconds = minutes * 60;
                    const parts = Math.ceil(duration / chunkSeconds);
                    const newTracks = [];
                    for (let i = 0; i < parts; i++) {
                        const start = i * chunkSeconds;
                        const end = Math.min((i + 1) * chunkSeconds, duration);
                        newTracks.push({
                            id: crypto.randomUUID(),
                            fileId: track.fileId,
                            name: `${track.name} - Part ${i + 1}`,
                            start: start,
                            duration: end - start
                        });
                    }
                    const updated = [...tracks];
                    updated.splice(idx, 1, ...newTracks);
                    setTracks(updated);
                    setStatus(`Split into ${parts} parts!`);
                } catch(e) { alert("Error splitting file."); } finally { setProcessing(false); setTimeout(() => setStatus(""), 2000); }
            };

            const executeSplitSilence = async () => {
                alert("Please use Time Split for large files.");
                setSplitTarget(null);
            };

            const sortTracks = () => {
                const sorted = [...tracks].sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
                setTracks(sorted);
            };

            const shuffleTracks = () => {
                setTracks(prev => {
                    const shuffled = [...prev];
                    for (let i = shuffled.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                    }
                    return shuffled;
                });
            };

            const removeTrack = (idx) => { setTracks(prev => prev.filter((_, i) => i !== idx)); };

            const handleSave = async () => {
                const id = bookId || crypto.randomUUID();
                let currentTrackIndex = 0;
                let currentTime = 0;
                if (bookId) {
                    const old = await dbOp('readonly', 'books', s => s.get(bookId));
                    if (old) { currentTrackIndex = old.currentTrackIndex; currentTime = old.currentTime; }
                }
                const book = { id, title, author, coverId, epubId, tracks, updatedAt: Date.now(), currentTrackIndex, currentTime };
                await dbOp('readwrite', 'books', s => s.put(book));
                onSave();
            };

            return (
                <div className="fixed inset-0 z-50 bg-ios-bg flex flex-col animate-in slide-in-from-bottom duration-300">
                    <div className="bg-white/90 backdrop-blur border-b border-ios-border px-4 py-3 flex justify-between items-center safe-top">
                        <button onClick={onClose} className="text-ios-blue font-medium">Cancel</button>
                        <span className="font-semibold">Edit Book</span>
                        <button onClick={handleSave} className="text-ios-blue font-bold">Save</button>
                    </div>

                    <div className="flex-1 overflow-y-auto p-4 pb-20 safe-bottom">
                        <div className="flex gap-4 mb-6">
                            <div className="w-28 h-28 bg-gray-200 rounded-lg flex-shrink-0 relative overflow-hidden group shadow-sm">
                                {coverPreview ? <img src={coverPreview} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center text-gray-400"><Icon name="image" /></div>}
                                <label className="absolute inset-0 bg-black/20 flex items-center justify-center opacity-0 group-hover:opacity-100 transition cursor-pointer">
                                    <span className="text-white text-xs font-bold bg-black/50 px-2 py-1 rounded">Edit</span>
                                    <input type="file" accept="image/*" className="hidden" onChange={handleCoverUpload} />
                                </label>
                            </div>
                            <div className="flex-1 space-y-3">
                                <input type="text" placeholder="Title" value={title} onChange={e => setTitle(e.target.value)} className="w-full bg-white p-2 rounded-lg border border-gray-200 text-lg font-semibold" />
                                <input type="text" placeholder="Author" value={author} onChange={e => setAuthor(e.target.value)} className="w-full bg-white p-2 rounded-lg border border-gray-200 text-gray-600" />
                            </div>
                        </div>

                        <div className="bg-white rounded-xl shadow-sm p-4 mb-6 flex items-center justify-between">
                            <div className="flex items-center gap-3">
                                <div className={`p-2 rounded-lg ${epubId ? 'bg-green-100 text-green-600' : 'bg-gray-100 text-gray-400'}`}><Icon name="book" size={20} /></div>
                                <div><h4 className="font-medium">E-Book File</h4><p className="text-xs text-gray-500">{epubId ? "EPUB Loaded" : "No EPUB uploaded"}</p></div>
                            </div>
                            <label className="text-sm font-medium text-ios-blue cursor-pointer bg-blue-50 px-3 py-1.5 rounded-full">{epubId ? "Change" : "Upload"}
                                <input type="file" accept=".epub,application/epub+zip" className="hidden" onChange={handleEpubUpload} />
                            </label>
                        </div>

                        <div className="mb-2 flex items-center justify-between px-1">
                            <h3 className="font-bold text-gray-500 uppercase tracking-wide text-xs">Audio Tracks ({tracks.length})</h3>
                            <div className="flex gap-2">
                                <button onClick={shuffleTracks} className="text-ios-blue text-xs font-medium">Shuffle</button>
                                <button onClick={sortTracks} className="text-ios-blue text-xs font-medium">Sort by Name</button>
                            </div>
                        </div>

                        <div className="bg-white rounded-xl shadow-sm overflow-hidden">
                            {tracks.length === 0 ? <div className="p-6 text-center text-gray-400 text-sm">No tracks yet.</div> : (
                                <div className="divide-y divide-gray-100">
                                    {tracks.map((t, idx) => (
                                        <div key={idx} className="p-3 flex items-center gap-3">
                                            <span className="text-gray-400 text-xs font-mono w-5">{idx + 1}</span>
                                            <div className="flex-1 min-w-0"><div className="truncate text-sm text-gray-800 font-medium">{t.name}</div><div className="text-xs text-gray-400">{t.start > 0 ? `Start: ${formatTime(t.start)}` : 'Full File'}{t.duration && ` • ${formatTime(t.duration)}`}</div></div>
                                            {(!t.duration || t.duration > 120) && <button onClick={() => openSplitMenu(idx)} className="text-gray-400 bg-gray-50 p-2 rounded-full hover:bg-ios-blue hover:text-white transition"><Icon name="scissors" size={16} /></button>}
                                            <button onClick={() => removeTrack(idx)} className="text-red-400 p-2 rounded-full hover:bg-red-50"><Icon name="minus-circle" size={16} /></button>
                                        </div>
                                    ))}
                                </div>
                            )}
                            <div className="p-3 bg-gray-50 border-t border-gray-100">
                                {processing ? <div className="flex flex-col items-center justify-center py-2 gap-2"><div className="animate-spin rounded-full h-5 w-5 border-b-2 border-ios-blue"></div><div className="text-xs text-gray-500">{status}</div></div> : (
                                    <label className="flex items-center justify-center gap-2 text-ios-blue font-semibold cursor-pointer w-full py-2"><Icon name="plus-circle" size={20} /> Add Audio Files
                                        <input type="file" multiple accept=".mp3,.wav,.m4a,audio/*" className="hidden" onChange={handleAddTracks} />
                                    </label>
                                )}
                            </div>
                        </div>
                    </div>
                    {splitTarget && <SplitOptions file={splitTarget.file} onSplitByTime={executeSplitByTime} onSplitSilence={executeSplitSilence} onCancel={() => setSplitTarget(null)} />}
                </div>
            );
        };

        const Player = ({ bookId, onBack }) => {
            const audioRef = useRef(null);
            const [book, setBook] = useState(null);
            const [cover, setCover] = useState(null);
            const [playing, setPlaying] = useState(false);
            const [time, setTime] = useState(0);
            const [dur, setDur] = useState(0); 
            const [showList, setShowList] = useState(false);
            const [showReader, setShowReader] = useState(false);
            const activeFileId = useRef(null);

            useEffect(() => {
                const load = async () => {
                    const b = await dbOp('readonly', 'books', s => s.get(bookId));
                    setBook(b);
                    if (b.coverId) {
                        const f = await dbOp('readonly', 'files', s => s.get(b.coverId));
                        if(f) setCover(URL.createObjectURL(f.data));
                    }
                    if (b.tracks.length > 0) await loadTrack(b, b.currentTrackIndex || 0, false);
                };
                load();
            }, [bookId]);

            const loadTrack = async (b, index, autoPlay) => {
                const track = b.tracks[index];
                if (!track) return;
                const fileId = track.fileId || track.id;
                const startTime = track.start || 0;
                
                if (activeFileId.current !== fileId) {
                    const f = await dbOp('readonly', 'files', s => s.get(fileId));
                    if (f) {
                        const url = URL.createObjectURL(f.data);
                        audioRef.current.src = url;
                        activeFileId.current = fileId;
                        audioRef.current.currentTime = (index === b.currentTrackIndex) ? (b.currentTime || startTime) : startTime;
                    }
                } else {
                    const buffer = 1; 
                    if (audioRef.current.currentTime < startTime - buffer || audioRef.current.currentTime > (track.start + (track.duration||99999))) {
                        audioRef.current.currentTime = startTime;
                    }
                }
                if (autoPlay) { try { await audioRef.current.play(); setPlaying(true); } catch(e){} }
            };

            const updateBookProgress = (t) => {
                if (!bookId) return;
                patchBook(bookId, { currentTime: t });
            };

            const changeTrack = async (idx) => {
                const b = { ...book, currentTrackIndex: idx };
                const t = b.tracks[idx];
                b.currentTime = t.start || 0; 
                setBook(b);
                await loadTrack(b, idx, true);
                patchBook(bookId, { currentTrackIndex: idx, currentTime: b.currentTime });
            };

            const handleTimeUpdate = () => {
                const ct = audioRef.current.currentTime;
                setTime(ct);
                setDur(audioRef.current.duration);
                updateBookProgress(ct);

                if (book && book.tracks[book.currentTrackIndex]) {
                    const current = book.tracks[book.currentTrackIndex];
                    const endTime = (current.start || 0) + (current.duration || 999999);
                    
                    if (current.duration && ct >= endTime - 0.2) {
                        if (book.currentTrackIndex < book.tracks.length - 1) {
                            const nextIndex = book.currentTrackIndex + 1;
                            const nextTrack = book.tracks[nextIndex];
                            setBook(prev => ({ ...prev, currentTrackIndex: nextIndex }));
                            
                            if ((nextTrack.fileId || nextTrack.id) === (current.fileId || current.id)) {
                                patchBook(bookId, { currentTrackIndex: nextIndex });
                            } else {
                                changeTrack(nextIndex);
                            }
                        } else {
                            setPlaying(false);
                        }
                    }
                }
            };

            if (!book) return null;

            const currentTrack = book.tracks[book.currentTrackIndex];
            const trackStart = currentTrack?.start || 0;
            const trackDur = currentTrack?.duration || dur;
            const sliderVal = time - trackStart;
            
            return (
                <div className="h-full flex flex-col bg-ios-bg">
                    <div className="safe-top px-4 pt-4 flex justify-between items-center z-10">
                        <button onClick={onBack} className="p-2 text-gray-500"><Icon name="chevron-down" /></button>
                        <span className="text-xs font-bold text-gray-400 uppercase tracking-widest">Now Playing</span>
                        <button onClick={() => setShowList(true)} className="p-2 text-gray-500"><Icon name="list" /></button>
                    </div>

                    <div className="flex-1 flex flex-col items-center justify-center p-8 space-y-8">
                        <div className={`w-full max-w-xs aspect-square rounded-2xl shadow-ios-float overflow-hidden bg-gray-200 transform transition-transform duration-500 ${playing ? 'scale-105' : 'scale-100'}`}>
                            {cover ? <img src={cover} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center text-gray-400"><Icon name="music" size={64} /></div>}
                        </div>

                        <div className="text-center w-full max-w-sm">
                            <h2 className="text-2xl font-bold truncate px-4">{book.title}</h2>
                            <p className="text-gray-500">{book.author}</p>
                            <div className="bg-blue-100 text-ios-blue text-xs font-bold px-3 py-1 rounded-full inline-block mt-2 truncate max-w-full">
                                {currentTrack?.name || "No Track"}
                            </div>
                        </div>

                        <div className="w-full max-w-sm px-4">
                            <input 
                                type="range" 
                                min="0" max={trackDur || 1} 
                                value={Math.max(0, sliderVal)} 
                                onChange={(e) => { 
                                    const seekTime = Number(e.target.value) + trackStart;
                                    audioRef.current.currentTime = seekTime; 
                                    setTime(seekTime); 
                                }}
                                className="w-full h-1 bg-gray-300 rounded-full"
                            />
                            <div className="flex justify-between text-xs text-gray-400 mt-2 font-mono">
                                <span>{formatTime(sliderVal)}</span>
                                <span>-{formatTime(trackDur - sliderVal)}</span>
                            </div>
                        </div>

                        <div className="flex items-center justify-between w-full max-w-xs px-6">
                            <button onClick={() => audioRef.current.currentTime -= 30} className="text-gray-800 flex flex-col items-center gap-1">
                                <Icon name="rotate-ccw" size={32} /> <span className="text-[10px] font-bold">30</span>
                            </button>
                            <button onClick={() => { if(playing) audioRef.current.pause(); else audioRef.current.play(); setPlaying(!playing); }} className="w-20 h-20 bg-slate-900 text-white rounded-full flex items-center justify-center shadow-lg active:scale-95 transition">
                                <Icon name={playing ? "pause" : "play"} size={36} className="ml-1 fill-current" />
                            </button>
                            <button onClick={() => audioRef.current.currentTime += 300} className="text-gray-800 flex flex-col items-center gap-1">
                                <Icon name="rotate-cw" size={32} /> <span className="text-[10px] font-bold">5m</span>
                            </button>
                        </div>
                    </div>

                    {book.epubId && (
                        <div className="safe-bottom pb-8 flex justify-center">
                             <button onClick={() => setShowReader(true)} className="flex items-center gap-2 bg-white px-5 py-3 rounded-full shadow-md text-sm font-bold text-gray-800">
                                <Icon name="book-open" size={18} /> Read Along
                            </button>
                        </div>
                    )}

                    {showList && (
                        <div className="absolute inset-0 z-20 bg-black/40 backdrop-blur-sm flex flex-col justify-end" onClick={() => setShowList(false)}>
                            <div className="bg-white rounded-t-3xl h-2/3 flex flex-col p-4 animate-in slide-in-from-bottom" onClick={e => e.stopPropagation()}>
                                <h3 className="text-lg font-bold mb-4 p-2">Chapters</h3>
                                <div className="overflow-y-auto flex-1">
                                    {book.tracks.map((t, i) => (
                                        <div key={i} onClick={() => { changeTrack(i); setShowList(false); }} className={`p-3 rounded-xl mb-1 flex items-center gap-3 ${i === book.currentTrackIndex ? 'bg-gray-100 text-ios-blue font-semibold' : 'text-gray-600'}`}>
                                            <span className="text-xs text-gray-400 w-6">{i + 1}</span>
                                            <span className="truncate">{t.name}</span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {showReader && <EpubReader bookId={bookId} onClose={() => setShowReader(false)} />}
                    
                    <audio 
                        ref={audioRef} 
                        onTimeUpdate={handleTimeUpdate} 
                        onEnded={() => { if(book.currentTrackIndex >= book.tracks.length - 1) setPlaying(false); }}
                        onError={(e) => console.log("Audio Error", e)}
                    />
                </div>
            );
        };

        const App = () => {
            const [view, setView] = useState('library'); 
            const [activeBookId, setActiveBookId] = useState(null);
            const [editingBookId, setEditingBookId] = useState(null);
            const [isEditing, setIsEditing] = useState(false);
            const [showSettings, setShowSettings] = useState(false);
            const [books, setBooks] = useState([]);
            const [covers, setCovers] = useState({});

            const loadLibrary = async () => {
                const list = await dbOp('readonly', 'books', s => s.getAll());
                setBooks(list);
                list.forEach(async b => {
                    if (b.coverId && !covers[b.id]) {
                        const f = await dbOp('readonly', 'files', s => s.get(b.coverId));
                        if(f) setCovers(prev => ({...prev, [b.id]: URL.createObjectURL(f.data)}));
                    }
                });
            };

            useEffect(() => { loadLibrary(); }, []);

            return (
                <>
                    {view === 'library' && (
                        <div className="h-full bg-ios-bg p-6 safe-top overflow-y-auto">
                            <header className="flex justify-between items-center mb-6">
                                <h1 className="text-3xl font-bold tracking-tight">Library</h1>
                                <div className="flex gap-2">
                                    <button onClick={() => setShowSettings(true)} className="bg-white text-gray-600 rounded-full p-2 shadow-sm border active:scale-95 transition">
                                        <Icon name="settings" size={20} />
                                    </button>
                                    <button onClick={() => { setEditingBookId(null); setIsEditing(true); }} className="bg-ios-blue text-white rounded-full p-2 shadow-lg active:scale-95 transition">
                                        <Icon name="plus" size={20} />
                                    </button>
                                </div>
                            </header>

                            <div className="grid grid-cols-2 gap-4 pb-20">
                                {books.map(b => (
                                    <div key={b.id} onClick={() => { setActiveBookId(b.id); setView('player'); }} className="relative group">
                                        <div className="aspect-square bg-white rounded-xl shadow-ios overflow-hidden mb-2 relative">
                                            {covers[b.id] ? <img src={covers[b.id]} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center bg-gray-100 text-gray-300"><Icon name="music" size={40} /></div>}
                                            <button 
                                                onClick={(e) => { e.stopPropagation(); setEditingBookId(b.id); setIsEditing(true); }}
                                                className="absolute top-2 right-2 bg-white/90 p-1.5 rounded-full shadow-sm opacity-0 group-hover:opacity-100 transition text-gray-700 hover:text-blue-600"
                                            >
                                                <Icon name="pencil" size={16} />
                                            </button>
                                        </div>
                                        <h3 className="font-semibold text-sm truncate leading-tight">{b.title}</h3>
                                        <p className="text-xs text-gray-500 truncate">{b.author}</p>
                                    </div>
                                ))}
                                {books.length === 0 && <div className="col-span-2 text-center text-gray-400 mt-20">Tap + to create a book</div>}
                            </div>
                        </div>
                    )}

                    {view === 'player' && <Player bookId={activeBookId} onBack={() => setView('library')} />}
                    
                    {isEditing && (
                        <BookEditor 
                            bookId={editingBookId} 
                            onClose={() => setIsEditing(false)} 
                            onSave={() => { setIsEditing(false); loadLibrary(); }} 
                        />
                    )}

                    {showSettings && <SettingsModal onClose={() => setShowSettings(false)} />}
                </>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
